This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-21T16:21:41.516Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/app.js
backend/config/constants.js
backend/constants/productDefaults.js
backend/db.js
backend/graphql/client.js
backend/graphql/enhancedClient.js
backend/graphql/mutations/contact.js
backend/graphql/mutations/invoice.js
backend/graphql/mutations/lineItem.js
backend/graphql/queries/contact.js
backend/graphql/queries/invoice.js
backend/graphql/queries/lineItem.js
backend/middleware/uploadMiddleware.js
backend/models/InventoryMapping.js
backend/routes/aiAssistant.js
backend/routes/documentParser.js
backend/routes/index.js
backend/routes/ocrRoutes.js
backend/routes/printavoRoutes.js
backend/scripts/seedMappings.js
backend/server.js
backend/services/accountService.js
backend/services/contactService.js
backend/services/enhancedSoapClient.js
backend/services/graphqlClient.js
backend/services/invoiceService.js
backend/services/lineItemService.js
backend/services/ocrService.js
backend/services/openaiService.js
backend/services/printavoService.js
backend/services/quoteService.js
backend/services/sanmarService.js
backend/tests/testConnections.js
backend/tests/testPrintavoConnection.js
backend/utils/envValidation.js
backend/utils/errorHandler.js
backend/utils/errorHandling.js
backend/utils/fileUtils.js
backend/utils/logger.js
backend/utils/ocrUtils.js
backend/utils/pdfUtils.js
backend/validation/utils.js
client/src/App.tsx
client/src/components/ApolloTest.tsx
client/src/components/ChatWidget.tsx
client/src/components/ui/accordion.tsx
client/src/components/ui/alert-dialog.tsx
client/src/components/ui/alert.tsx
client/src/components/ui/aspect-ratio.tsx
client/src/components/ui/avatar.tsx
client/src/components/ui/badge.tsx
client/src/components/ui/button.tsx
client/src/components/ui/calendar.tsx
client/src/components/ui/card.tsx
client/src/env.d.ts
client/src/graphql/queries.ts
client/src/lib/apollo.ts
client/src/lib/utils.ts
client/src/main.tsx
client/src/services/api.ts
client/src/vite-env.d.ts
docs/architecture.md
docs/data_models.md
docs/how_it_works.md
docs/Printavo/auth.md
docs/Printavo/Connections.md
docs/Printavo/Directives.md
docs/Printavo/Enums.md
docs/Printavo/graphql_concepts.md
docs/Printavo/Interfaces.md
docs/Printavo/Mutations.md
docs/Printavo/objects.md
docs/Printavo/operations.md
docs/Printavo/queries_gemini.md
docs/Printavo/Scalars.md
docs/Printavo/unions.md
docs/README.md
docs/Sanmar/Sanmar_integration.md
docs/setup.md
src/lib/utils.ts

================================================================
Files
================================================================

================
File: backend/app.js
================
import 'dotenv/config';
import express from 'express';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { connectDB } from './db.js';
import indexRouter from './routes/index.js';
import ocrRoutes from './routes/ocrRoutes.js';
import printavoRoutes from './routes/printavoRoutes.js';

const app = express();

// Log environment variables (excluding sensitive data)
const safeEnvVars = { ...process.env };
delete safeEnvVars.PRINTAVO_ACCESS_TOKEN;
delete safeEnvVars.SANMAR_PASSWORD;
console.log('Environment variables:', safeEnvVars);

// Check MongoDB connection string
if (!process.env.MONGODB_URI) {
  console.error('Error: MONGODB_URI environment variable is not set.');
  process.exit(1);
}

// Connect to MongoDB
connectDB().catch(err => {
  console.error('Failed to connect to MongoDB:', err);
  process.exit(1);
});

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api', indexRouter);
app.use('/api/ocr', ocrRoutes);
app.use('/api/printavo', printavoRoutes);

// Basic test route
app.get('/', (req, res) => {
  res.send('SanMar Integration Service is running.');
});

// 404 handler
app.use((req, res, next) => {
  res.status(404).json({
    success: false,
    error: 'Not Found'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err.message);
  console.error('Stack:', err.stack);
  
  // Handle specific error types
  if (err.name === 'PrintavoAPIError') {
    return res.status(err.code === 'AUTHENTICATION_ERROR' ? 401 : 500).json({
      success: false,
      error: err.message,
      code: err.code
    });
  }
  
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      error: 'Validation Error',
      details: err.details || err.message
    });
  }

  // Default error response
  res.status(500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'An unexpected error occurred'
      : err.message || 'Something broke!'
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});

export default app; // For testing purposes

================
File: backend/config/constants.js
================
module.exports = {
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
  MIN_FILE_SIZE: 1024, // 1KB
  MAX_PDF_PAGES: 10,
  MIN_OCR_CONFIDENCE: 60,
  MAX_LINE_ITEMS: 100,
  ALLOWED_FILE_TYPES: ['image/png', 'image/jpeg', 'image/jpg', 'application/pdf'],
  UPLOADS_DIR: 'uploads'
};

================
File: backend/constants/productDefaults.js
================
/**
 * Standard size distributions for different market segments
 */
const SIZE_DISTRIBUTIONS = {
  STANDARD_RETAIL: {
    "S": 1,
    "M": 2,
    "L": 2,
    "XL": 1
  },
  STANDARD_PLUS: {
    "S": 1,
    "M": 2,
    "L": 2,
    "XL": 2,
    "2XL": 1
  },
  YOUTH: {
    "YXS": 1,
    "YS": 2,
    "YM": 2,
    "YL": 1
  },
  UNIFORM: {
    "S": 2,
    "M": 3,
    "L": 3,
    "XL": 2
  },
  CORPORATE: {
    "M": 3,
    "L": 4,
    "XL": 2,
    "2XL": 1
  }
};

/**
 * Common product categories with their typical configurations
 */
const PRODUCT_DEFAULTS = {
  TSHIRT: {
    defaultSizing: "STANDARD_RETAIL",
    commonColors: ["Black", "White", "Navy", "Gray"],
    commonLocations: ["Front Center", "Back Center", "Left Chest"]
  },
  POLO: {
    defaultSizing: "CORPORATE",
    commonColors: ["Black", "Navy", "White"],
    commonLocations: ["Left Chest", "Right Chest", "Right Sleeve"]
  },
  HOODIE: {
    defaultSizing: "STANDARD_PLUS",
    commonColors: ["Black", "Gray", "Navy"],
    commonLocations: ["Front Center", "Back Center", "Left Chest"]
  },
  YOUTH_TSHIRT: {
    defaultSizing: "YOUTH",
    commonColors: ["Black", "White", "Navy", "Red"],
    commonLocations: ["Front Center", "Back Center"]
  }
};

/**
 * Standard imprint locations with their typical specifications
 */
const IMPRINT_LOCATIONS = {
  "Front Center": {
    maxWidth: "12 inches",
    maxHeight: "14 inches",
    commonColors: 4
  },
  "Back Center": {
    maxWidth: "12 inches",
    maxHeight: "14 inches",
    commonColors: 4
  },
  "Left Chest": {
    maxWidth: "4 inches",
    maxHeight: "4 inches",
    commonColors: 2
  },
  "Right Chest": {
    maxWidth: "4 inches",
    maxHeight: "4 inches",
    commonColors: 2
  },
  "Right Sleeve": {
    maxWidth: "3 inches",
    maxHeight: "3 inches",
    commonColors: 1
  },
  "Left Sleeve": {
    maxWidth: "3 inches",
    maxHeight: "3 inches",
    commonColors: 1
  }
};

module.exports = {
  SIZE_DISTRIBUTIONS,
  PRODUCT_DEFAULTS,
  IMPRINT_LOCATIONS
};

================
File: backend/db.js
================
import 'dotenv/config';
import mongoose from 'mongoose';

export async function connectDB() {
  const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/sanmar_integration';
  
  try {
    await mongoose.connect(mongoUri, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected successfully');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }

  mongoose.connection.on('error', err => {
    console.error('MongoDB connection error:', err);
  });

  mongoose.connection.on('disconnected', () => {
    console.warn('MongoDB disconnected. Attempting to reconnect...');
  });
}

================
File: backend/graphql/client.js
================
import { GraphQLClient } from 'graphql-request';
import dotenv from 'dotenv';

dotenv.config();

const client = new GraphQLClient(process.env.PRINTAVO_API_URL, {
    headers: {
        Authorization: `Bearer ${process.env.PRINTAVO_ACCESS_TOKEN}`,
    },
});

const clientPromise = Promise.resolve(client);

/**
 * Executes a GraphQL query or mutation
 * @param {string} query GraphQL query or mutation string
 * @param {Object} variables Query variables
 * @returns {Promise<Object>} GraphQL response data
 */
async function executeGraphQL(query, variables = {}) {
  try {
    const data = await client.request(query, variables);
    return data;
  } catch (error) {
    console.error('GraphQL Error:', error);
    throw error;
  }
}

export { clientPromise, executeGraphQL };
export default client;

================
File: backend/graphql/enhancedClient.js
================
/**
 * @fileoverview Enhanced GraphQL Client
 * Provides a robust GraphQL client with retry logic, timeout handling,
 * and comprehensive error management
 */

const { GraphQLClient } = require('graphql-request');
const { validatePrintavoEnv } = require('../utils/envValidation');
const { 
  PrintavoAPIError, 
  PrintavoValidationError,
  PrintavoAuthenticationError,
  ERROR_CODES 
} = require('../utils/errorHandling');
const { LOG_LEVELS, log } = require('../utils/logger');

// Configuration constants
const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 1000; // 1 second
const MAX_RETRY_DELAY = 5000; // 5 seconds
const REQUEST_TIMEOUT = 30000; // 30 seconds

class EnhancedGraphQLClient {
  constructor() {
    this.client = null;
    this.initializeClient();
  }

  /**
   * Initialize the GraphQL client with environment validation
   * @private
   */
  initializeClient() {
    try {
      // Validate environment variables
      validatePrintavoEnv();

      this.client = new GraphQLClient(process.env.PRINTAVO_API_URL, {
        headers: {
          Authorization: `Bearer ${process.env.PRINTAVO_ACCESS_TOKEN}`,
          'X-Printavo-Email': process.env.PRINTAVO_EMAIL
        },
        timeout: REQUEST_TIMEOUT
      });

      log(LOG_LEVELS.INFO, 'GraphQLClient', {
        action: 'initialize',
        message: 'GraphQL client initialized successfully'
      });
    } catch (error) {
      log(LOG_LEVELS.ERROR, 'GraphQLClient', {
        action: 'initialize',
        status: 'failed',
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Classify GraphQL errors into specific error types
   * @private
   * @param {Error} error The error to classify
   * @returns {Error} Classified error
   */
  classifyError(error) {
    // Network or timeout errors
    if (error.type === 'system') {
      return new PrintavoAPIError(
        'Network or system error occurred',
        ERROR_CODES.SYSTEM.NETWORK,
        { originalError: error.message }
      );
    }

    // Authentication errors
    if (error.response?.errors?.some(e => e.extensions?.code === 'UNAUTHENTICATED')) {
      return new PrintavoAuthenticationError(
        'Authentication failed',
        ERROR_CODES.API.UNAUTHORIZED,
        { originalError: error.message }
      );
    }

    // Validation errors
    if (error.response?.errors?.some(e => e.extensions?.code === 'BAD_USER_INPUT')) {
      return new PrintavoValidationError(
        'Invalid input data',
        error.response.errors.map(e => ({
          message: e.message,
          path: e.path
        }))
      );
    }

    // Rate limiting
    if (error.response?.errors?.some(e => e.extensions?.code === 'RATE_LIMITED')) {
      return new PrintavoAPIError(
        'Rate limit exceeded',
        ERROR_CODES.API.RATE_LIMITED,
        { originalError: error.message }
      );
    }

    // Default to generic API error
    return new PrintavoAPIError(
      error.message,
      ERROR_CODES.API.SERVICE_UNAVAILABLE,
      { originalError: error.message }
    );
  }

  /**
   * Calculate exponential backoff delay
   * @private
   * @param {number} retryCount Current retry attempt
   * @returns {number} Delay in milliseconds
   */
  calculateBackoff(retryCount) {
    const delay = Math.min(
      INITIAL_RETRY_DELAY * Math.pow(2, retryCount),
      MAX_RETRY_DELAY
    );
    return delay + Math.random() * 1000; // Add jitter
  }

  /**
   * Check if error is retryable
   * @private
   * @param {Error} error The error to check
   * @returns {boolean} Whether the error is retryable
   */
  isRetryableError(error) {
    // Network errors are retryable
    if (error.type === 'system') return true;

    // Rate limiting errors are retryable
    if (error.response?.errors?.some(e => e.extensions?.code === 'RATE_LIMITED')) {
      return true;
    }

    // Service unavailable errors are retryable
    if (error.response?.errors?.some(e => 
      e.extensions?.code === 'SERVICE_UNAVAILABLE' ||
      e.extensions?.code === 'INTERNAL_SERVER_ERROR'
    )) {
      return true;
    }

    return false;
  }

  /**
   * Execute a GraphQL request with retry logic
   * @param {string} query GraphQL query or mutation
   * @param {Object} variables Query variables
   * @returns {Promise<Object>} Query result
   * @throws {PrintavoAPIError} On non-retryable errors or max retries exceeded
   */
  async request(query, variables = {}) {
    let lastError = null;
    
    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      try {
        const result = await this.client.request(query, variables);
        return result;
      } catch (error) {
        lastError = error;
        
        // Don't retry if error is not retryable
        if (!this.isRetryableError(error)) {
          throw this.classifyError(error);
        }

        // If we've exhausted retries, throw the error
        if (attempt === MAX_RETRIES) {
          throw this.classifyError(error);
        }

        // Log retry attempt
        log(LOG_LEVELS.WARN, 'GraphQLClient', {
          action: 'retry',
          attempt: attempt + 1,
          error: error.message
        });

        // Wait before retrying
        const delay = this.calculateBackoff(attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    // This shouldn't be reached due to the throw in the loop
    throw this.classifyError(lastError);
  }
}

// Export singleton instance
const client = new EnhancedGraphQLClient();
module.exports = client;

================
File: backend/graphql/mutations/contact.js
================
/**
 * @typedef {Object} ContactCreateInput
 * @property {string} fullName - Full name of the contact
 * @property {string} email - Email address
 * @property {string} [phone] - Phone number
 * @property {Object} [address] - Contact address
 * @property {string} address.address1 - Street address line 1
 * @property {string} [address.address2] - Street address line 2
 * @property {string} address.city - City
 * @property {string} address.stateIso - State/Province ISO code
 * @property {string} address.zipCode - Postal/ZIP code
 * @property {string} address.countryIso - Country ISO code
 * @property {boolean} [primaryContact] - Whether this is a primary contact
 * @property {Object} [company] - Associated company
 * @property {string} company.id - Company ID
 */

const CREATE_CONTACT = `
  mutation CreateContact($input: ContactCreateInput!) {
    contactCreate(input: $input) {
      contact {
        id
        fullName
        email
        phone
        address {
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        primaryContact
        company {
          id
          name
        }
      }
      errors {
        message
        path
      }
    }
  }
`;

const UPDATE_CONTACT = `
  mutation UpdateContact($id: ID!, $input: ContactUpdateInput!) {
    contactUpdate(id: $id, input: $input) {
      contact {
        id
        fullName
        email
        phone
        address {
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        primaryContact
        company {
          id
          name
        }
      }
      errors {
        message
        path
      }
    }
  }
`;

const DELETE_CONTACT = `
  mutation DeleteContact($id: ID!) {
    contactDelete(id: $id) {
      success
      errors {
        message
        path
      }
    }
  }
`;

module.exports = {
  CREATE_CONTACT,
  UPDATE_CONTACT,
  DELETE_CONTACT
};

================
File: backend/graphql/mutations/invoice.js
================
/**
 * @typedef {Object} InvoiceCreateInput
 * @property {string} contactId - ID of the contact
 * @property {string} [dueDate] - Due date for the invoice
 * @property {Array<{
 *   productId: string,
 *   quantity: number,
 *   size: string,
 *   color: string,
 *   price: number,
 *   imprints?: Array<{
 *     name: string,
 *     description?: string,
 *     location: string,
 *     colors: Array<string>
 *   }>
 * }>} lineItems - Array of line items
 * @property {Object} [shippingAddress] - Shipping address
 * @property {Object} [billingAddress] - Billing address
 * @property {string} [customerNote] - Customer-facing note
 * @property {string} [productionNote] - Production-specific note
 * @property {string} [internalNote] - Internal note
 * @property {Array<string>} [tags] - Array of tags
 * @property {string} [statusId] - ID of the invoice status
 * @property {string} [paymentTermsId] - ID of the payment terms
 * @property {string} [deliveryMethodId] - ID of the delivery method
 * @property {number} [depositRequired] - Required deposit amount
 */

const CREATE_INVOICE = `
  mutation CreateInvoice($input: InvoiceCreateInput!) {
    invoiceCreate(input: $input) {
      invoice {
        id
        visualId
        customerDueAt
        contact {
          id
          email
          fullName
        }
        status {
          id
          name
          color
        }
        lineItemGroups {
          nodes {
            id
            name
            lineItems {
              nodes {
                id
                quantity
                size
                color
                price
                product {
                  id
                  name
                  sku
                }
              }
            }
          }
        }
        shippingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        billingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        customerNote
        productionNote
        internalNote
        tags
        paymentStatus
        paymentTerms {
          id
          name
        }
        deliveryMethod {
          id
          name
        }
        subtotal
        tax
        shipping
        total
        balance
        depositRequired
      }
      errors {
        message
        path
      }
    }
  }
`;

const UPDATE_INVOICE = `
  mutation UpdateInvoice($id: ID!, $input: InvoiceUpdateInput!) {
    invoiceUpdate(id: $id, input: $input) {
      invoice {
        id
        visualId
        customerDueAt
        contact {
          id
          email
          fullName
        }
        status {
          id
          name
          color
        }
        lineItemGroups {
          nodes {
            id
            name
            lineItems {
              nodes {
                id
                quantity
                size
                color
                price
                product {
                  id
                  name
                  sku
                }
              }
            }
          }
        }
        shippingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        billingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        customerNote
        productionNote
        internalNote
        tags
        paymentStatus
        paymentTerms {
          id
          name
        }
        deliveryMethod {
          id
          name
        }
        subtotal
        tax
        shipping
        total
        balance
        depositRequired
        depositPaid
      }
      errors {
        message
        path
      }
    }
  }
`;

const DELETE_INVOICE = `
  mutation DeleteInvoice($id: ID!) {
    invoiceDelete(id: $id) {
      success
      errors {
        message
        path
      }
    }
  }
`;

module.exports = {
  CREATE_INVOICE,
  UPDATE_INVOICE,
  DELETE_INVOICE
};

================
File: backend/graphql/mutations/lineItem.js
================
/**
 * @typedef {Object} LineItemCreateInput
 * @property {Object} product - Product information
 * @property {string} product.id - Product ID
 * @property {number} quantity - Quantity ordered
 * @property {string} [size] - Size selected
 * @property {string} [color] - Color selected
 * @property {number} [price] - Price per unit
 * @property {number} [cost] - Cost per unit
 * @property {number} [markup] - Markup percentage
 * @property {Array<{
 *   name: string,
 *   description?: string,
 *   location: string,
 *   colors: Array<string>
 * }>} [imprints] - Array of imprint specifications
 */

const CREATE_LINE_ITEM = `
  mutation CreateLineItem($input: LineItemCreateInput!) {
    lineItemCreate(input: $input) {
      lineItem {
        id
        product {
          id
          name
          sku
          description
          category {
            id
            name
          }
        }
        quantity
        size
        color
        price
        cost
        markup
        profit
        mockups {
          nodes {
            id
            url
            position
          }
        }
        imprints {
          nodes {
            id
            name
            description
            location
            colors
            mockupUrl
          }
        }
      }
      errors {
        message
        path
      }
    }
  }
`;

const UPDATE_LINE_ITEM = `
  mutation UpdateLineItem($id: ID!, $input: LineItemUpdateInput!) {
    lineItemUpdate(id: $id, input: $input) {
      lineItem {
        id
        product {
          id
          name
          sku
          description
          category {
            id
            name
          }
        }
        quantity
        size
        color
        price
        cost
        markup
        profit
        mockups {
          nodes {
            id
            url
            position
          }
        }
        imprints {
          nodes {
            id
            name
            description
            location
            colors
            mockupUrl
          }
        }
      }
      errors {
        message
        path
      }
    }
  }
`;

const DELETE_LINE_ITEM = `
  mutation DeleteLineItem($id: ID!) {
    lineItemDelete(id: $id) {
      success
      errors {
        message
        path
      }
    }
  }
`;

module.exports = {
  CREATE_LINE_ITEM,
  UPDATE_LINE_ITEM,
  DELETE_LINE_ITEM
};

================
File: backend/graphql/queries/contact.js
================
/**
 * @typedef {Object} ContactFragment
 * @property {string} id - Contact ID
 * @property {string} fullName - Full name
 * @property {string} email - Email address
 * @property {string} phone - Phone number
 * @property {Object} address - Contact address
 * @property {string} address.address1 - Street address line 1
 * @property {string} [address.address2] - Street address line 2
 * @property {string} address.city - City
 * @property {string} address.stateIso - State/Province ISO code
 * @property {string} address.zipCode - Postal/ZIP code
 * @property {string} address.countryIso - Country ISO code
 * @property {boolean} primaryContact - Whether this is a primary contact
 * @property {Object} company - Associated company
 * @property {string} company.id - Company ID
 * @property {string} company.name - Company name
 */

/**
 * @typedef {Object} ContactSearchOptions
 * @property {string} query - Search query (email, name, or phone)
 * @property {number} [first=25] - Number of results to return (max 25)
 * @property {string} [after] - Cursor for pagination
 * @property {boolean} [primaryOnly=false] - Only search primary contacts
 * @property {string} [sortOn='CREATED_AT'] - Field to sort on
 * @property {boolean} [sortDescending=true] - Sort in descending order
 */

const SEARCH_CONTACTS = `
  query SearchContacts(
    $query: String!
    $first: Int
    $after: String
    $primaryOnly: Boolean
    $sortOn: ContactSortField
    $sortDescending: Boolean
  ) {
    contacts(
      query: $query
      first: $first
      after: $after
      primaryOnly: $primaryOnly
      sortOn: $sortOn
      sortDescending: $sortDescending
    ) {
      nodes {
        id
        fullName
        email
        phone
        address {
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        primaryContact
        company {
          id
          name
        }
        timestamps {
          createdAt
          updatedAt
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalNodes
    }
  }
`;

const GET_CONTACT = `
  query GetContact($id: ID!) {
    contact(id: $id) {
      id
      fullName
      email
      phone
      address {
        address1
        address2
        city
        stateIso
        zipCode
        countryIso
      }
      primaryContact
      company {
        id
        name
      }
      invoices(first: 5) {
        nodes {
          id
          visualId
          customerDueAt
          status {
            id
            name
          }
        }
      }
      timestamps {
        createdAt
        updatedAt
      }
    }
  }
`;

module.exports = {
  SEARCH_CONTACTS,
  GET_CONTACT
};

================
File: backend/graphql/queries/invoice.js
================
/**
 * @typedef {Object} InvoiceQueryOptions
 * @property {number} [first=25] - Number of invoices to fetch (max 25)
 * @property {string} [after] - Cursor for pagination
 * @property {string[]} [statusIds] - Filter by status IDs
 * @property {string} [inProductionAfter] - Filter by production start date
 * @property {string} [inProductionBefore] - Filter by production end date
 * @property {string} [paymentStatus] - Filter by payment status
 * @property {string} [sortOn] - Field to sort on
 * @property {boolean} [sortDescending] - Sort direction
 * @property {string} [searchTerm] - Search term for filtering
 * @property {string[]} [tags] - Filter by tags
 */

const GET_INVOICE = `
  query GetInvoice($id: ID!) {
    invoice(id: $id) {
      id
      visualId
      customerDueAt
      contact {
        id
        email
        fullName
        phone
        company {
          id
          name
        }
      }
      owner {
        id
        email
        firstName
        lastName
      }
      status {
        id
        name
        color
        type
        position
      }
      lineItemGroups {
        nodes {
          id
          name
          description
          position
          lineItems {
            nodes {
              id
              product {
                id
                name
                sku
                description
                category {
                  id
                  name
                }
              }
              quantity
              size
              color
              price
              cost
              markup
              profit
              mockups {
                nodes {
                  id
                  url
                  position
                }
              }
              imprints {
                nodes {
                  id
                  name
                  description
                  location
                  colors
                  mockupUrl
                }
              }
            }
          }
        }
      }
      shippingAddress {
        companyName
        customerName
        address1
        address2
        city
        stateIso
        zipCode
        countryIso
      }
      billingAddress {
        companyName
        customerName
        address1
        address2
        city
        stateIso
        zipCode
        countryIso
      }
      customerNote
      productionNote
      internalNote
      tags
      paymentStatus
      paymentProcessor
      paymentTerms {
        id
        name
        description
        daysUntilDue
      }
      deliveryMethod {
        id
        name
        description
      }
      approvals {
        nodes {
          id
          status
          requestedAt
          respondedAt
          mockupUrl
        }
      }
      subtotal
      tax
      shipping
      total
      balance
      depositRequired
      depositPaid
      timestamps {
        createdAt
        updatedAt
        deletedAt
        inProductionAt
        completedAt
      }
    }
  }
`;

const GET_RECENT_INVOICES = `
  query GetRecentInvoices(
    $first: Int
    $after: String
    $statusIds: [ID!]
    $inProductionAfter: ISO8601DateTime
    $inProductionBefore: ISO8601DateTime
    $paymentStatus: OrderPaymentStatus
    $sortOn: OrderSortField
    $sortDescending: Boolean
    $searchTerm: String
    $tags: [String!]
  ) {
    invoices(
      first: $first
      after: $after
      statusIds: $statusIds
      inProductionAfter: $inProductionAfter
      inProductionBefore: $inProductionBefore
      paymentStatus: $paymentStatus
      sortOn: $sortOn
      sortDescending: $sortDescending
      searchTerm: $searchTerm
      tags: $tags
    ) {
      nodes {
        id
        visualId
        customerDueAt
        contact {
          id
          email
          fullName
          company {
            id
            name
          }
        }
        status {
          id
          name
          color
          type
        }
        lineItemGroups {
          nodes {
            id
            name
            lineItems {
              nodes {
                id
                quantity
                size
                color
                price
                product {
                  id
                  name
                  sku
                }
              }
            }
          }
        }
        paymentStatus
        subtotal
        tax
        shipping
        total
        balance
        tags
        timestamps {
          createdAt
          updatedAt
          inProductionAt
          completedAt
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalNodes
    }
  }
`;

module.exports = {
  GET_INVOICE,
  GET_RECENT_INVOICES
};

================
File: backend/graphql/queries/lineItem.js
================
/**
 * @typedef {Object} LineItemFragment
 * @property {string} id - Line item ID
 * @property {Object} product - Product information
 * @property {string} product.id - Product ID
 * @property {string} product.name - Product name
 * @property {string} product.sku - Product SKU
 * @property {string} product.description - Product description
 * @property {Object} product.category - Product category
 * @property {number} quantity - Quantity ordered
 * @property {string} size - Size selected
 * @property {string} color - Color selected
 * @property {number} price - Price per unit
 * @property {number} cost - Cost per unit
 * @property {number} markup - Markup percentage
 * @property {number} profit - Profit amount
 */

const GET_LINE_ITEM = `
  query GetLineItem($id: ID!) {
    lineItem(id: $id) {
      id
      product {
        id
        name
        sku
        description
        category {
          id
          name
        }
      }
      quantity
      size
      color
      price
      cost
      markup
      profit
      mockups {
        nodes {
          id
          url
          position
        }
      }
      imprints {
        nodes {
          id
          name
          description
          location
          colors
          mockupUrl
        }
      }
      timestamps {
        createdAt
        updatedAt
      }
    }
  }
`;

module.exports = {
  GET_LINE_ITEM
};

================
File: backend/middleware/uploadMiddleware.js
================
const multer = require('multer');
const fs = require('fs').promises;
const path = require('path');

// Move multer configuration and upload middleware here

module.exports = { uploadMiddleware };

================
File: backend/models/InventoryMapping.js
================
const mongoose = require('mongoose');

const InventoryMappingSchema = new mongoose.Schema({
  // Printavo fields
  printavoStyleCode: { 
    type: String, 
    required: true,
    trim: true,
    uppercase: true
  },
  color: { 
    type: String, 
    required: true,
    trim: true
  },
  size: { 
    type: String, 
    required: true,
    trim: true,
    uppercase: true
  },
  
  // SanMar fields
  sanmarInventoryKey: { 
    type: String, 
    required: true,
    trim: true,
    uppercase: true
  },
  sizeIndex: { 
    type: String, 
    required: true,
    trim: true,
    uppercase: true
  },
  warehouse: { 
    type: String, 
    default: 'ATL',
    trim: true,
    uppercase: true
  },

  // Additional metadata
  description: {
    type: String,
    trim: true
  },
  active: {
    type: Boolean,
    default: true
  },
  lastUpdated: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  collection: 'inventory_mappings'
});

// Create a compound index for unique combinations
InventoryMappingSchema.index(
  { printavoStyleCode: 1, color: 1, size: 1 }, 
  { unique: true }
);

// Instance method to convert to SanMar format
InventoryMappingSchema.methods.toSanmarFormat = function() {
  return {
    inventoryKey: this.sanmarInventoryKey,
    sizeIndex: this.sizeIndex,
    warehouse: this.warehouse
  };
};

const InventoryMapping = mongoose.model('InventoryMapping', InventoryMappingSchema);

module.exports = InventoryMapping;

================
File: backend/routes/aiAssistant.js
================
const express = require('express');
const router = express.Router();
const { generateResponse } = require('../services/openaiService');
const { createQuote } = require('../services/quoteService');

router.post('/ai-assistant', async (req, res) => {
  try {
    const { userMessage, conversationHistory = [] } = req.body;

    // Generate response using OpenAI
    const response = await generateResponse(userMessage, conversationHistory);

    if (!response.success) {
      return res.status(500).json({ 
        error: 'Failed to generate response',
        details: response.error
      });
    }

    res.json({ reply: response.reply });

  } catch (error) {
    console.error('AI Assistant Error:', error);
    res.status(500).json({ 
      error: 'Failed to process request',
      details: error.message
    });
  }
});

module.exports = router;

================
File: backend/routes/documentParser.js
================
const express = require('express');
const router = express.Router();
const multer = require('multer');
const { processInvoice } = require('../services/ocrService');
const { parseLineItems } = require('../services/lineItemService');
const { createQuote } = require('../services/quoteService');

// Configure multer for file upload
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf' || file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only PDF and images are allowed.'));
    }
  }
});

router.post('/parse-document', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    // Process the document with OCR
    const extractedText = await processInvoice(req.file.buffer);
    
    // Parse line items from the extracted text
    const lineItems = await parseLineItems(extractedText);

    // Extract potential contact information using regex
    const emailMatch = extractedText.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
    const phoneMatch = extractedText.match(/(\+\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}/);
    
    // Create quote preview
    const quotePreview = {
      contact: {
        email: emailMatch ? emailMatch[0] : null,
        phone: phoneMatch ? phoneMatch[0] : null
      },
      lineItems,
      customerNote: "Generated from uploaded document"
    };

    res.json({ 
      quote: quotePreview,
      rawText: extractedText // Include for debugging
    });

  } catch (error) {
    console.error('Document parsing error:', error);
    res.status(500).json({ 
      error: 'Failed to process document',
      details: error.message
    });
  }
});

router.post('/quotes', async (req, res) => {
  try {
    const quoteData = req.body;
    const quote = await createQuote(quoteData);
    res.json(quote);
  } catch (error) {
    console.error('Quote creation error:', error);
    res.status(500).json({ 
      error: 'Failed to create quote',
      details: error.message
    });
  }
});

module.exports = router;

================
File: backend/routes/index.js
================
import express from 'express';
import { getPreSubmitInfo, submitPO } from '../services/sanmarService.js';

const router = express.Router();

// Health check route
router.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Test getPreSubmitInfo endpoint
router.get('/test-get-presubmit', async (req, res) => {
  try {
    // Example test items
    const testLineItems = [
      {
        inventoryKey: 'PC61BLK',
        quantity: 12,
        sizeIndex: 'L',
        warehouse: 'ATL'
      }
    ];
    const response = await getPreSubmitInfo(testLineItems);
    res.json({ success: true, response });
  } catch (error) {
    console.error('PreSubmit Error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Test submitPO endpoint
router.post('/test-submit-po', async (req, res) => {
  try {
    const { poNumber, shipToName, lineItems, ...shippingDetails } = req.body;

    if (!poNumber || !shipToName || !lineItems) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: poNumber, shipToName, or lineItems'
      });
    }

    const response = await submitPO({
      poNumber,
      shipToName,
      ...shippingDetails,
      lineItems
    });

    res.json({ success: true, response });
  } catch (error) {
    console.error('Submit PO Error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

export default router;

================
File: backend/routes/ocrRoutes.js
================
const express = require('express');
const multer = require('multer');
const ocrService = require('../services/ocrService');
const { uploadMiddleware } = require('../middleware/uploadMiddleware');

const router = express.Router();

router.post('/upload-invoice', uploadMiddleware, async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ 
        success: false, 
        error: 'No file uploaded',
        code: 'NO_FILE'
      });
    }

    const result = await ocrService.processInvoice(req.file);
    res.json(result);
  } catch (error) {
    // Error handling
  }
});

module.exports = router;

================
File: backend/routes/printavoRoutes.js
================
const express = require('express');
const router = express.Router();
const printavoService = require('../services/printavoService');

// Get a specific invoice
router.get('/invoices/:id', async (req, res) => {
  try {
    const invoice = await printavoService.getInvoice(req.params.id);
    res.json({
      success: true,
      invoice
    });
  } catch (error) {
    console.error('Error fetching invoice:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get recent invoices with pagination
router.get('/invoices', async (req, res) => {
  try {
    const { first = 10, after } = req.query;
    const invoices = await printavoService.getRecentInvoices(
      parseInt(first, 10),
      after
    );
    res.json({
      success: true,
      ...invoices
    });
  } catch (error) {
    console.error('Error fetching invoices:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Create a new invoice
router.post('/invoices', async (req, res) => {
  try {
    const invoice = await printavoService.createInvoice(req.body);
    res.json({
      success: true,
      invoice
    });
  } catch (error) {
    console.error('Error creating invoice:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Search invoices
router.post('/invoices/search', async (req, res) => {
  try {
    const { statusIds, dateRange, first } = req.body;
    const invoices = await printavoService.searchInvoices({
      statusIds,
      dateRange,
      first
    });
    res.json({
      success: true,
      invoices
    });
  } catch (error) {
    console.error('Error searching invoices:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Create invoice from OCR results
router.post('/invoices/from-ocr', async (req, res) => {
  try {
    const { contactId, lineItems, shippingAddress } = req.body;
    
    // Validate required fields
    if (!contactId || !lineItems || !shippingAddress) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: contactId, lineItems, or shippingAddress'
      });
    }

    // Format line items for Printavo
    const formattedLineItems = lineItems.map(item => ({
      productId: item.productId,
      quantity: item.quantity,
      price: item.price,
      size: item.size,
      color: item.color
    }));

    // Create invoice in Printavo
    const invoice = await printavoService.createInvoice({
      contactId,
      lineItems: formattedLineItems,
      shippingAddress,
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days from now
    });

    res.json({
      success: true,
      invoice
    });
  } catch (error) {
    console.error('Error creating invoice from OCR:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get account information
router.get('/account', async (req, res) => {
  try {
    const account = await printavoService.getAccount();
    res.json({
      success: true,
      account
    });
  } catch (error) {
    console.error('Error fetching account:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;

================
File: backend/scripts/seedMappings.js
================
require('dotenv').config();
const connectDB = require('../db');
const InventoryMapping = require('../models/InventoryMapping');

const sampleMappings = [
  {
    printavoStyleCode: 'PC61',
    color: 'Black',
    size: 'L',
    sanmarInventoryKey: 'PC61BLK',
    sizeIndex: 'L',
    warehouse: 'ATL',
    description: 'Port & Company Essential T-Shirt - Black'
  },
  {
    printavoStyleCode: 'PC61',
    color: 'Navy',
    size: 'XL',
    sanmarInventoryKey: 'PC61NVY',
    sizeIndex: 'XL',
    warehouse: 'ATL',
    description: 'Port & Company Essential T-Shirt - Navy'
  }
];

async function seedDatabase() {
  try {
    await connectDB();
    
    // Clear existing mappings if needed
    console.log('Clearing existing mappings...');
    await InventoryMapping.deleteMany({});
    
    // Insert new mappings
    console.log('Inserting sample mappings...');
    await InventoryMapping.insertMany(sampleMappings);
    
    console.log('Database seeded successfully!');
    process.exit(0);
  } catch (error) {
    console.error('Error seeding database:', error);
    process.exit(1);
  }
}

seedDatabase();

================
File: backend/server.js
================
const express = require('express');
const path = require('path');
const cors = require('cors');
const documentParser = require('./routes/documentParser');
const aiAssistant = require('./routes/aiAssistant');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'client/build')));

// API routes
app.use('/api', documentParser);
app.use('/api', aiAssistant);

// Serve React app
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'client/build/index.html'));
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: 'Something went wrong!',
    details: err.message
  });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

================
File: backend/services/accountService.js
================
import { LOG_LEVELS, log } from '../utils/logger.js';
import { executeGraphQL, clientPromise } from '../graphql/client.js';
import { PrintavoAPIError, PrintavoValidationError } from '../utils/errorHandling.js';

// GraphQL queries
const GET_ACCOUNT = `
  query Account {
    account {
      id
      companyName
      companyEmail
      phone
      website
      locale
      logoUrl
      paymentProcessorPresent
      address {
        address1
        address2
        city
        stateIso
        zipCode
        countryIso
      }
      catalogInformation {
        sanmar
        alphabroder
        ssActivewear
      }
      features
      enabledLineItemGroupColumns {
        quantity
        size
        color
        price
        cost
        markup
        profit
      }
      lineItemGroupSizes {
        code
        name
        size
      }
      timestamps {
        createdAt
        updatedAt
      }
    }
  }
`;

const GET_ACCOUNT_USERS = `
  query GetAccountUsers($first: Int, $after: String) {
    account {
      users(first: $first, after: $after) {
        nodes {
          id
          email
          firstName
          lastName
          role
          active
          avatar {
            urlSmall
            backgroundColor
            initials
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
        totalNodes
      }
    }
  }
`;

const GET_ACCOUNT_STATUSES = `
  query GetAccountStatuses($type: StatusType) {
    account {
      orderStatuses(type: $type) {
        nodes {
          id
          name
          color
          type
          position
          timestamps {
            createdAt
            updatedAt
          }
        }
      }
    }
  }
`;

const UPDATE_ACCOUNT = `
  mutation UpdateAccount($input: AccountUpdateInput!) {
    accountUpdate(input: $input) {
      account {
        id
        companyName
        companyEmail
        phone
        website
        locale
        address {
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
      }
      errors {
        message
        path
      }
    }
  }
`;

/**
 * Get account details
 * @returns {Promise<Object>} Account data
 */
async function getAccount() {
  log(LOG_LEVELS.INFO, 'Fetching account details');
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(GET_ACCOUNT);
    if (!data?.account) {
      throw new PrintavoAPIError(
        'No account data returned',
        'FETCH_ERROR'
      );
    }
    return data.account;
  } catch (error) {
    if (error instanceof PrintavoAPIError) {
      throw error;
    }
    throw new PrintavoAPIError(
      'Failed to fetch account details',
      'FETCH_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Get account users with pagination
 * @param {Object} options Query options
 * @param {number} options.first Number of users to fetch (max 25)
 * @param {string} options.after Cursor for pagination
 * @returns {Promise<Object>} Users data with pagination info
 */
async function getAccountUsers(options = {}) {
  const { first = 25, after = null } = options;
  log(LOG_LEVELS.INFO, 'Fetching account users', { first, after });
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(GET_ACCOUNT_USERS, { first, after });
    if (!data?.account?.users) {
      throw new PrintavoAPIError(
        'No users data returned',
        'FETCH_ERROR'
      );
    }
    return data.account.users;
  } catch (error) {
    throw new PrintavoAPIError(
      'Failed to fetch account users',
      'FETCH_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Get account order statuses filtered by type
 * @param {string} type Status type filter (QUOTE, INVOICE, etc.)
 * @returns {Promise<Array>} List of order statuses
 */
async function getAccountStatuses(type = null) {
  log(LOG_LEVELS.INFO, 'Fetching account statuses', { type });
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(GET_ACCOUNT_STATUSES, { type });
    if (!data?.account?.orderStatuses?.nodes) {
      throw new PrintavoAPIError(
        'No status data returned',
        'FETCH_ERROR'
      );
    }
    return data.account.orderStatuses.nodes;
  } catch (error) {
    throw new PrintavoAPIError(
      'Failed to fetch account statuses',
      'FETCH_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Update account details
 * @param {Object} updateData Account update data
 * @returns {Promise<Object>} Updated account data
 */
async function updateAccount(updateData) {
  log(LOG_LEVELS.INFO, 'Updating account details');
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(UPDATE_ACCOUNT, {
      input: updateData
    });
    
    const response = data?.accountUpdate;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from update mutation',
        'UPDATE_ERROR'
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Account update failed',
        { errors: response.errors }
      );
    }
    
    return response.account;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoAPIError(
      'Failed to update account',
      'UPDATE_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Check if specific catalog integration is enabled
 * @param {string} catalog Catalog name (sanmar, alphabroder, ssActivewear)
 * @returns {Promise<boolean>} Whether the catalog is enabled
 */
async function isCatalogEnabled(catalog) {
  log(LOG_LEVELS.INFO, 'Checking catalog status', { catalog });
  
  try {
    const account = await getAccount();
    return account.catalogInformation?.[catalog] || false;
  } catch (error) {
    throw new PrintavoAPIError(
      'Failed to check catalog status',
      'FETCH_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Verify connection to Printavo API
 * @returns {Promise<boolean>} Connection status
 */
async function verifyConnection() {
  log(LOG_LEVELS.INFO, 'Verifying Printavo API connection');
  
  try {
    const account = await getAccount();
    return Boolean(account?.id);
  } catch (error) {
    log(LOG_LEVELS.ERROR, 'API connection verification failed', {
      error: error.message
    });
    return false;
  }
}

export {
  getAccount,
  getAccountUsers,
  getAccountStatuses,
  updateAccount,
  isCatalogEnabled,
  verifyConnection
};

================
File: backend/services/contactService.js
================
import { LOG_LEVELS, log } from '../utils/logger.js';
import { executeGraphQL, clientPromise } from '../graphql/client.js';
import { PrintavoAPIError, PrintavoValidationError, ERROR_CODES } from '../utils/errorHandling.js';
import { SEARCH_CONTACTS, GET_CONTACT } from '../graphql/queries/contact.js';
import { CREATE_CONTACT, UPDATE_CONTACT, DELETE_CONTACT } from '../graphql/mutations/contact.js';

// Constants
const DEFAULT_PAGE_SIZE = 25;
const DEFAULT_SORT_FIELD = 'CREATED_AT';
const DEFAULT_SORT_DIRECTION = true; // descending

const SERVICE_NAME = 'ContactService';

/**
 * Validate contact input data
 * @param {import('../graphql/mutations/contact').ContactCreateInput} contactData 
 * @throws {PrintavoValidationError} When validation fails
 */
function validateContactInput(contactData) {
  if (!contactData.fullName?.trim()) {
      throw new PrintavoValidationError(
        'Full name is required',
        { field: 'fullName', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
  }
  
  if (!contactData.email?.trim()) {
      throw new PrintavoValidationError(
        'Email is required',
        { field: 'email', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
  }
  
  // Basic email format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(contactData.email)) {
      throw new PrintavoValidationError(
        'Invalid email format',
        { field: 'email', code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
      );
  }
  
  if (contactData.address) {
    if (!contactData.address.address1?.trim()) {
      throw new PrintavoValidationError(
        'Street address is required when providing address',
        { field: 'address.address1', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }
    if (!contactData.address.city?.trim()) {
      throw new PrintavoValidationError(
        'City is required when providing address',
        { field: 'address.city', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }
    if (!contactData.address.stateIso?.trim()) {
      throw new PrintavoValidationError(
        'State is required when providing address',
        { field: 'address.stateIso', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }
    if (!contactData.address.zipCode?.trim()) {
      throw new PrintavoValidationError(
        'ZIP code is required when providing address',
        { field: 'address.zipCode', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }
    if (!contactData.address.countryIso?.trim()) {
      throw new PrintavoValidationError(
        'Country is required when providing address',
        { field: 'address.countryIso', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }
  }
}

/**
 * Find contacts by search query
 * @param {import('../graphql/queries/contact').ContactSearchOptions} options - Search options
 * @returns {Promise<{
 *   nodes: Array<import('../graphql/queries/contact').ContactFragment>,
 *   pageInfo: { hasNextPage: boolean, endCursor: string },
 *   totalNodes: number
 * }>} Search results with pagination info
 * @throws {PrintavoAPIError} When search fails
 */
async function findContacts(options) {
  const { 
    query, 
    first = DEFAULT_PAGE_SIZE, 
    after = null, 
    primaryOnly = false,
    sortOn = DEFAULT_SORT_FIELD,
    sortDescending = DEFAULT_SORT_DIRECTION
  } = options;
  
  if (!query?.trim()) {
      throw new PrintavoValidationError(
        'Search query is required',
        { field: 'query', code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
  }
  
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'findContacts',
    query,
    first,
    after,
    primaryOnly,
    sortOn,
    sortDescending
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(SEARCH_CONTACTS, {
      query,
      first: Math.min(first, DEFAULT_PAGE_SIZE),
      after,
      primaryOnly,
      sortOn,
      sortDescending
    });
    
    if (!data?.contacts) {
      throw new PrintavoAPIError(
        'No contacts data returned',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { action: 'findContacts' }
      );
    }
    
    return data.contacts;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to search for contacts',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'findContacts',
          originalError: error.message,
          query
        }
      );
  }
}

/**
 * Get a contact by ID
 * @param {string} id - Contact ID
 * @returns {Promise<import('../graphql/queries/contact').ContactFragment>} Contact data
 * @throws {PrintavoAPIError} When contact is not found or fetch fails
 */
async function getContact(id) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'getContact',
    id 
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(GET_CONTACT, { id });
    if (!data?.contact) {
      throw new PrintavoAPIError(
        'Contact not found',
        ERROR_CODES.DATA.NOT_FOUND,
        { 
          action: 'getContact',
          id 
        }
      );
    }
    
    return data.contact;
  } catch (error) {
    if (error instanceof PrintavoAPIError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to fetch contact',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'getContact',
          id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Create a new contact
 * @param {import('../graphql/mutations/contact').ContactCreateInput} contactData - Contact creation data
 * @returns {Promise<import('../graphql/queries/contact').ContactFragment>} Created contact
 * @throws {PrintavoValidationError} When input validation fails
 * @throws {PrintavoAPIError} When creation fails
 */
async function createContact(contactData) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'createContact',
    email: contactData.email,
    fullName: contactData.fullName
  });
  
  try {
    validateContactInput(contactData);
    await clientPromise;
    
    const data = await executeGraphQL(CREATE_CONTACT, {
      input: contactData
    });
    
    const response = data?.contactCreate;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from create mutation',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'createContact',
          email: contactData.email 
        }
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Contact creation failed',
        response.errors,
        { 
          action: 'createContact',
          email: contactData.email 
        }
      );
    }
    
    return response.contact;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to create contact',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'createContact',
          email: contactData.email,
          originalError: error.message 
        }
      );
  }
}

/**
 * Update a contact's information
 * @param {string} id - Contact ID
 * @param {Object} updateData - Contact update data following ContactUpdateInput schema
 * @returns {Promise<import('../graphql/queries/contact').ContactFragment>} Updated contact
 * @throws {PrintavoValidationError} When update validation fails
 * @throws {PrintavoAPIError} When update fails
 */
async function updateContact(id, updateData) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'updateContact',
    id,
    updateFields: Object.keys(updateData)
  });
  
  try {
    if (updateData.email || updateData.fullName || updateData.address) {
      validateContactInput({
        ...updateData,
        email: updateData.email || 'placeholder@example.com', // Add placeholder for partial validation
        fullName: updateData.fullName || 'Placeholder Name'
      });
    }
    
    await clientPromise;
    
    const data = await executeGraphQL(UPDATE_CONTACT, {
      id,
      input: updateData
    });
    
    const response = data?.contactUpdate;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from update mutation',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'updateContact',
          id 
        }
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Contact update failed',
        response.errors,
        { 
          action: 'updateContact',
          id 
        }
      );
    }
    
    return response.contact;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to update contact',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'updateContact',
          id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Delete a contact
 * @param {string} id - Contact ID
 * @returns {Promise<boolean>} Success status
 * @throws {PrintavoValidationError} When deletion validation fails
 * @throws {PrintavoAPIError} When deletion fails
 */
async function deleteContact(id) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'deleteContact',
    id 
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(DELETE_CONTACT, { id });
    
    const response = data?.contactDelete;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from delete mutation',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'deleteContact',
          id 
        }
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Contact deletion failed',
        response.errors,
        { 
          action: 'deleteContact',
          id 
        }
      );
    }
    
    return response.success;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to delete contact',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'deleteContact',
          id,
          originalError: error.message 
        }
      );
  }
}

export {
  findContacts,
  getContact,
  createContact,
  updateContact,
  deleteContact,
  // Export constants for testing
  DEFAULT_PAGE_SIZE,
  DEFAULT_SORT_FIELD,
  DEFAULT_SORT_DIRECTION
};

================
File: backend/services/enhancedSoapClient.js
================
/**
 * @fileoverview Enhanced SOAP Client
 * Provides a robust SOAP client with retry logic, timeout handling,
 * and comprehensive error management
 */

import { soap } from 'strong-soap';
import { loadSanMarConfig } from '../utils/envValidation.js';
import { SanMarAPIError, ERROR_CODES } from '../utils/errorHandling.js';
import { LOG_LEVELS, log } from '../utils/logger.js';

// Configuration constants
const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 1000; // 1 second
const MAX_RETRY_DELAY = 5000; // 5 seconds
const REQUEST_TIMEOUT = 30000; // 30 seconds

class EnhancedSoapClient {
  constructor() {
    this.client = null;
    this.initialized = false;
    this.config = null;
  }

  /**
   * Initialize the SOAP client with environment validation
   * @private
   * @returns {Promise<void>}
   * @throws {SanMarAPIError} If initialization fails
   */
  async initialize() {
    if (this.initialized) return;

    try {
      // Load and validate configuration
      this.config = loadSanMarConfig();
      
      // Create SOAP client
      this.client = await this.createSoapClient();
      this.initialized = true;

      log(LOG_LEVELS.INFO, 'SoapClient', {
        action: 'initialize',
        message: 'SOAP client initialized successfully'
      });
    } catch (error) {
      log(LOG_LEVELS.ERROR, 'SoapClient', {
        action: 'initialize',
        status: 'failed',
        error: error.message
      });

      // Re-throw SanMarAPIError instances
      if (error instanceof SanMarAPIError) {
        throw error;
      }

      throw this.classifyError(error);
    }
  }

  /**
   * Create SOAP client with security
   * @private
   * @returns {Promise<Object>} SOAP client instance
   * @throws {SanMarAPIError} If client creation fails
   */
  createSoapClient() {
    return new Promise((resolve, reject) => {
      const options = {
        request: {
          timeout: REQUEST_TIMEOUT
        },
        wsdl_options: {
          timeout: REQUEST_TIMEOUT
        }
      };

      soap.createClient(this.config.wsdlUrl, options, (err, client) => {
        if (err) return reject(err);
        
        try {
          // Add WS-Security
          client.setSecurity(new soap.WSSecurity(
            this.config.username,
            this.config.password,
            { 
              hasTimeStamp: true,
              hasTokenCreated: true
            }
          ));

          resolve(client);
        } catch (error) {
          reject(SanMarAPIError.wsSecurityError(
            'Failed to configure WS-Security',
            { originalError: error.message }
          ));
        }
      });
    });
  }

  /**
   * Classify SOAP errors into specific error types
   * @private
   * @param {Error} error The error to classify
   * @returns {SanMarAPIError} Classified error
   */
  classifyError(error) {
    // WS-Security errors
    if (error.message?.includes('Invalid security token') ||
        error.message?.includes('Security header') ||
        error.message?.includes('WSSecurity')) {
      return SanMarAPIError.wsSecurityError(
        'WS-Security authentication failed',
        { originalError: error.message }
      );
    }

    // Authentication errors
    if (error.message?.includes('Authentication failed') || 
        error.message?.includes('Invalid credentials')) {
      return SanMarAPIError.authError(
        'Authentication failed',
        { originalError: error.message }
      );
    }

    // Timeout errors
    if (error.code === 'ETIMEDOUT' || error.message?.includes('timeout')) {
      return new SanMarAPIError(
        'Request timed out',
        ERROR_CODES.SYSTEM.NETWORK,
        { originalError: error.message }
      );
    }

    // WSDL parsing errors
    if (error.message?.includes('WSDL')) {
      return SanMarAPIError.configError(
        'WSDL configuration error',
        { originalError: error.message }
      );
    }

    // Network errors
    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
      return new SanMarAPIError(
        'Network connection error',
        ERROR_CODES.SYSTEM.NETWORK,
        { originalError: error.message }
      );
    }

    // Default to generic API error
    return new SanMarAPIError(
      error.message || 'Unknown SanMar API error',
      ERROR_CODES.API.SERVICE_UNAVAILABLE,
      { originalError: error.message }
    );
  }

  /**
   * Calculate exponential backoff delay
   * @private
   * @param {number} retryCount Current retry attempt
   * @returns {number} Delay in milliseconds
   */
  calculateBackoff(retryCount) {
    const delay = Math.min(
      INITIAL_RETRY_DELAY * Math.pow(2, retryCount),
      MAX_RETRY_DELAY
    );
    return delay + Math.random() * 1000; // Add jitter
  }

  /**
   * Check if error is retryable
   * @private
   * @param {Error} error The error to check
   * @returns {boolean} Whether the error is retryable
   */
  isRetryableError(error) {
    // Never retry authentication or WS-Security errors
    if (error instanceof SanMarAPIError) {
      if (error.code === ERROR_CODES.API.UNAUTHORIZED ||
          error.code === ERROR_CODES.VALIDATION.INVALID_CREDENTIALS) {
        return false;
      }
    }

    // Timeout errors are retryable
    if (error.code === 'ETIMEDOUT' || error.message?.includes('timeout')) {
      return true;
    }

    // Network errors are retryable
    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
      return true;
    }

    // Service errors are retryable
    if (error.message?.includes('Service Unavailable') ||
        error.message?.includes('Internal Server Error')) {
      return true;
    }

    return false;
  }

  /**
   * Execute a SOAP method with retry logic
   * @param {string} method SOAP method name
   * @param {Object} args Method arguments
   * @returns {Promise<Object>} Method result
   * @throws {SanMarAPIError} On non-retryable errors or max retries exceeded
   */
  async execute(method, args) {
    await this.initialize();

    let lastError = null;
    
    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      try {
        const result = await new Promise((resolve, reject) => {
          this.client[method](args, (error, result) => {
            if (error) reject(error);
            else resolve(result);
          });
        });

        // Validate response structure
        if (!result || typeof result !== 'object') {
          throw new Error('Invalid response structure');
        }

        // Check for empty array edge case
        if (Array.isArray(result) && result.length === 0) {
          return { items: [] }; // Return standardized empty response
        }

        return result;
      } catch (error) {
        lastError = error;
        
        // Classify the error
        const classifiedError = this.classifyError(error);

        // Don't retry if error is not retryable
        if (!this.isRetryableError(classifiedError)) {
          throw classifiedError;
        }

        // If we've exhausted retries, throw the error
        if (attempt === MAX_RETRIES) {
          throw classifiedError;
        }

        // Log retry attempt
        log(LOG_LEVELS.WARN, 'SoapClient', {
          action: 'retry',
          method,
          attempt: attempt + 1,
          error: error.message
        });

        // Wait before retrying
        const delay = this.calculateBackoff(attempt);
        await new Promise(resolve => setTimeout(resolve, delay));

        // Re-initialize client on retry
        this.initialized = false;
        await this.initialize();
      }
    }

    // This shouldn't be reached due to the throw in the loop
    throw this.classifyError(lastError);
  }
}

// Export singleton instance
const client = new EnhancedSoapClient();
export default client;

================
File: backend/services/graphqlClient.js
================


================
File: backend/services/invoiceService.js
================
const { LOG_LEVELS, log } = require('../utils/logger');
const { executeGraphQL, clientPromise } = require('../graphql/client');
const { validateInvoiceInput } = require('../validation/utils');
const { PrintavoAPIError, PrintavoValidationError, ERROR_CODES } = require('../utils/errorHandling');
const { GET_INVOICE, GET_RECENT_INVOICES } = require('../graphql/queries/invoice');
const { CREATE_INVOICE, UPDATE_INVOICE, DELETE_INVOICE } = require('../graphql/mutations/invoice');

// Constants
const DEFAULT_PAGE_SIZE = 25;
const DEFAULT_SORT_FIELD = 'CREATED_AT';
const DEFAULT_SORT_DIRECTION = true; // descending
const DEFAULT_DUE_DATE_DAYS = 7;

const SERVICE_NAME = 'InvoiceService';

/**
 * Fetch an invoice by ID
 * @param {string} invoiceId - The invoice ID
 * @returns {Promise<Object>} The invoice data
 * @throws {PrintavoAPIError} When invoice is not found or fetch fails
 */
async function getInvoice(invoiceId) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'getInvoice',
    invoiceId 
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(GET_INVOICE, { id: invoiceId });
    if (!data?.invoice) {
      throw new PrintavoAPIError(
        'Invoice not found',
        ERROR_CODES.DATA.NOT_FOUND,
        { 
          action: 'getInvoice',
          id: invoiceId 
        }
      );
    }
    return data.invoice;
  } catch (error) {
    if (error instanceof PrintavoAPIError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to fetch invoice',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'getInvoice',
          id: invoiceId,
          originalError: error.message 
        }
      );
  }
}

/**
 * Fetch recent invoices with pagination and sorting
 * @param {import('../graphql/queries/invoice').InvoiceQueryOptions} options - Query options
 * @returns {Promise<Object>} The invoices data with pagination info
 * @throws {PrintavoAPIError} When fetch fails
 */
async function getRecentInvoices(options = {}) {
  const {
    first = DEFAULT_PAGE_SIZE,
    after = null,
    statusIds = null,
    inProductionAfter = null,
    inProductionBefore = null,
    paymentStatus = null,
    sortOn = DEFAULT_SORT_FIELD,
    sortDescending = DEFAULT_SORT_DIRECTION,
    searchTerm = null,
    tags = null
  } = options;

  log(LOG_LEVELS.INFO, SERVICE_NAME, {
    action: 'getRecentInvoices',
    first,
    after,
    statusIds,
    paymentStatus,
    sortOn
  });

  try {
    await clientPromise;
    
    const data = await executeGraphQL(GET_RECENT_INVOICES, {
      first: Math.min(first, DEFAULT_PAGE_SIZE),
      after,
      statusIds,
      inProductionAfter,
      inProductionBefore,
      paymentStatus,
      sortOn,
      sortDescending,
      searchTerm,
      tags
    });

    if (!data?.invoices) {
      throw new PrintavoAPIError(
        'No invoices data returned',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { action: 'getRecentInvoices' }
      );
    }

    return data.invoices;
  } catch (error) {
      throw new PrintavoAPIError(
        'Failed to fetch recent invoices',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'getRecentInvoices',
          originalError: error.message,
          options: { first, statusIds, paymentStatus }
        }
      );
  }
}

/**
 * Create a new invoice
 * @param {import('../graphql/mutations/invoice').InvoiceCreateInput} invoiceData - The invoice data
 * @returns {Promise<Object>} The created invoice
 * @throws {PrintavoValidationError} When input validation fails
 * @throws {PrintavoAPIError} When creation fails
 */
async function createInvoice(invoiceData) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, {
    action: 'createInvoice',
    contactId: invoiceData.contactId,
    lineItemsCount: invoiceData.lineItems?.length
  });
  
  try {
    await clientPromise;
    validateInvoiceInput(invoiceData);
    
    const input = {
      contact: { id: invoiceData.contactId },
      customerDueAt: invoiceData.dueDate || 
        new Date(Date.now() + DEFAULT_DUE_DATE_DAYS * 24 * 60 * 60 * 1000).toISOString(),
      lineItemGroups: [{
        lineItems: invoiceData.lineItems.map(item => ({
          product: { id: item.productId },
          quantity: item.quantity,
          size: item.size,
          color: item.color,
          price: item.price,
          imprints: item.imprints?.map(imp => ({
            name: imp.name,
            description: imp.description,
            location: imp.location,
            colors: imp.colors
          }))
        }))
      }],
      shippingAddress: invoiceData.shippingAddress,
      billingAddress: invoiceData.billingAddress,
      customerNote: invoiceData.customerNote,
      productionNote: invoiceData.productionNote,
      internalNote: invoiceData.internalNote,
      tags: invoiceData.tags,
      status: invoiceData.statusId ? { id: invoiceData.statusId } : undefined,
      paymentTerms: invoiceData.paymentTermsId ? { id: invoiceData.paymentTermsId } : undefined,
      deliveryMethod: invoiceData.deliveryMethodId ? { id: invoiceData.deliveryMethodId } : undefined,
      depositRequired: invoiceData.depositRequired
    };
    
    const data = await executeGraphQL(CREATE_INVOICE, { input });
    const response = data.invoiceCreate;
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Invoice creation failed',
        response.errors,
        { 
          action: 'createInvoice',
          contactId: invoiceData.contactId 
        }
      );
    }
    
    return response.invoice;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to create invoice',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'createInvoice',
          contactId: invoiceData.contactId,
          originalError: error.message 
        }
      );
  }
}

/**
 * Update an existing invoice
 * @param {string} id - Invoice ID
 * @param {Object} updateData - Update data following InvoiceUpdateInput schema
 * @returns {Promise<Object>} Updated invoice
 * @throws {PrintavoValidationError} When update validation fails
 * @throws {PrintavoAPIError} When update fails
 */
async function updateInvoice(id, updateData) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'updateInvoice',
    id,
    updateFields: Object.keys(updateData)
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(UPDATE_INVOICE, {
      id,
      input: updateData
    });
    
    const response = data.invoiceUpdate;
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Invoice update failed',
        response.errors,
        { 
          action: 'updateInvoice',
          id 
        }
      );
    }
    
    return response.invoice;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to update invoice',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'updateInvoice',
          id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Delete an invoice
 * @param {string} id - Invoice ID
 * @returns {Promise<boolean>} Success status
 * @throws {PrintavoValidationError} When deletion validation fails
 * @throws {PrintavoAPIError} When deletion fails
 */
async function deleteInvoice(id) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'deleteInvoice',
    id 
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(DELETE_INVOICE, { id });
    
    const response = data.invoiceDelete;
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Invoice deletion failed',
        response.errors,
        { 
          action: 'deleteInvoice',
          id 
        }
      );
    }
    
    return response.success;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to delete invoice',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'deleteInvoice',
          id,
          originalError: error.message 
        }
      );
  }
}

module.exports = {
  getInvoice,
  getRecentInvoices,
  createInvoice,
  updateInvoice,
  deleteInvoice,
  // Export constants for testing and reuse
  DEFAULT_PAGE_SIZE,
  DEFAULT_SORT_FIELD,
  DEFAULT_SORT_DIRECTION,
  DEFAULT_DUE_DATE_DAYS
};

================
File: backend/services/lineItemService.js
================
const { LOG_LEVELS, log } = require('../utils/logger');
const { executeGraphQL, clientPromise } = require('../graphql/client');
const { PrintavoAPIError, PrintavoValidationError, ERROR_CODES } = require('../utils/errorHandling');
const InventoryMapping = require('../models/InventoryMapping');
const { GET_LINE_ITEM } = require('../graphql/queries/lineItem');
const { CREATE_LINE_ITEM, UPDATE_LINE_ITEM, DELETE_LINE_ITEM } = require('../graphql/mutations/lineItem');

// Constants
const SERVICE_NAME = 'LineItemService';

const REGEX_PATTERNS = {
  QUANTITY: /qty:?\s*(\d+)|quantity:?\s*(\d+)|(\d+)\s*pc?s?/i,
  SIZE: /size:?\s*([xsml\d]+)/i,
  COLOR: /colou?r:?\s*(\w+)/i
};

/**
 * Get a line item by ID
 * @param {string} id - Line item ID
 * @returns {Promise<import('../graphql/queries/lineItem').LineItemFragment>} Line item data
 * @throws {PrintavoAPIError} When line item is not found or fetch fails
 */
async function getLineItem(id) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'getLineItem',
    id 
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(GET_LINE_ITEM, { id });
    if (!data?.lineItem) {
      throw new PrintavoAPIError(
        'Line item not found',
        ERROR_CODES.DATA.NOT_FOUND,
        { 
          action: 'getLineItem',
          id 
        }
      );
    }
    return data.lineItem;
  } catch (error) {
    if (error instanceof PrintavoAPIError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to fetch line item',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'getLineItem',
          id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Validate line item input data
 * @param {import('../graphql/mutations/lineItem').LineItemCreateInput} lineItemData 
 * @throws {PrintavoValidationError} When validation fails
 */
function validateLineItemInput(lineItemData) {
  if (!lineItemData.product?.id) {
    throw new PrintavoValidationError(
      'Product ID is required',
      { field: 'product.id' },
      { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
    );
  }
  if (!lineItemData.quantity || lineItemData.quantity < 1) {
    throw new PrintavoValidationError(
      'Quantity must be greater than 0',
      { field: 'quantity' },
      { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
    );
  }
}

/**
 * Create a new line item
 * @param {import('../graphql/mutations/lineItem').LineItemCreateInput} lineItemData - Line item creation data
 * @returns {Promise<import('../graphql/queries/lineItem').LineItemFragment>} Created line item
 * @throws {PrintavoValidationError} When input validation fails
 * @throws {PrintavoAPIError} When creation fails
 */
async function createLineItem(lineItemData) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'createLineItem',
    productId: lineItemData.product?.id,
    quantity: lineItemData.quantity
  });
  
  try {
    validateLineItemInput(lineItemData);
    await clientPromise;
    
    const data = await executeGraphQL(CREATE_LINE_ITEM, {
      input: {
        product: { id: lineItemData.product.id },
        quantity: lineItemData.quantity,
        size: lineItemData.size,
        color: lineItemData.color,
        price: lineItemData.price,
        cost: lineItemData.cost,
        markup: lineItemData.markup,
        imprints: lineItemData.imprints?.map(imp => ({
          name: imp.name,
          description: imp.description,
          location: imp.location,
          colors: imp.colors
        }))
      }
    });
    
    const response = data?.lineItemCreate;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from create mutation',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'createLineItem',
          productId: lineItemData.product?.id 
        }
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Line item creation failed',
        response.errors,
        { 
          action: 'createLineItem',
          productId: lineItemData.product?.id 
        }
      );
    }
    
    return response.lineItem;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to create line item',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'createLineItem',
          productId: lineItemData.product?.id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Update a line item
 * @param {string} id - Line item ID
 * @param {Object} updateData - Update data following LineItemUpdateInput schema
 * @returns {Promise<import('../graphql/queries/lineItem').LineItemFragment>} Updated line item
 * @throws {PrintavoValidationError} When update validation fails
 * @throws {PrintavoAPIError} When update fails
 */
async function updateLineItem(id, updateData) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'updateLineItem',
    id,
    updateFields: Object.keys(updateData)
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(UPDATE_LINE_ITEM, {
      id,
      input: updateData
    });
    
    const response = data?.lineItemUpdate;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from update mutation',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'updateLineItem',
          id 
        }
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Line item update failed',
        response.errors,
        { 
          action: 'updateLineItem',
          id 
        }
      );
    }
    
    return response.lineItem;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to update line item',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'updateLineItem',
          id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Delete a line item
 * @param {string} id - Line item ID
 * @returns {Promise<boolean>} Success status
 * @throws {PrintavoValidationError} When deletion validation fails
 * @throws {PrintavoAPIError} When deletion fails
 */
async function deleteLineItem(id) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, { 
    action: 'deleteLineItem',
    id 
  });
  
  try {
    await clientPromise;
    
    const data = await executeGraphQL(DELETE_LINE_ITEM, { id });
    
    const response = data?.lineItemDelete;
    if (!response) {
      throw new PrintavoAPIError(
        'No response from delete mutation',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'deleteLineItem',
          id 
        }
      );
    }
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Line item deletion failed',
        response.errors,
        { 
          action: 'deleteLineItem',
          id 
        }
      );
    }
    
    return response.success;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoAPIError(
        'Failed to delete line item',
        ERROR_CODES.API.SERVICE_UNAVAILABLE,
        { 
          action: 'deleteLineItem',
          id,
          originalError: error.message 
        }
      );
  }
}

/**
 * Extract line item information from a text line
 * @param {string} line - Text line to parse
 * @param {Object} currentItem - Current line item being built
 * @returns {Object} Updated line item data
 */
function parseLineItemInfo(line, currentItem) {
  if (!currentItem) return null;

  // Look for quantity
  const quantityMatch = line.match(REGEX_PATTERNS.QUANTITY);
  if (quantityMatch) {
    const qty = parseInt(quantityMatch[1] || quantityMatch[2] || quantityMatch[3]);
    if (!isNaN(qty)) {
      currentItem.quantity = qty;
    }
    return currentItem;
  }
  
  // Look for size
  const sizeMatch = line.match(REGEX_PATTERNS.SIZE);
  if (sizeMatch) {
    currentItem.size = sizeMatch[1].toUpperCase();
    return currentItem;
  }
  
  // Look for color
  const colorMatch = line.match(REGEX_PATTERNS.COLOR);
  if (colorMatch) {
    currentItem.color = colorMatch[1];
    return currentItem;
  }

  return currentItem;
}

/**
 * Parse line items from OCR text using inventory mappings
 * @param {string} text - The OCR extracted text to parse
 * @returns {Promise<Array<Object>>} Array of parsed line items
 * @throws {PrintavoValidationError} When parsing fails or no valid items found
 */
async function parseLineItems(text) {
  log(LOG_LEVELS.INFO, SERVICE_NAME, {
    action: 'parseLineItems',
    textLength: text.length
  });
  
  try {
    const mappings = await InventoryMapping.find({}).lean();
    if (!mappings?.length) {
      throw new PrintavoValidationError(
        'No inventory mappings found',
        [{ message: 'Please run the seed script to populate inventory mappings' }],
        { 
          code: ERROR_CODES.DATA.NOT_FOUND,
          action: 'parseLineItems'
        }
      );
    }
    
    const lines = text
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);
      
    const lineItems = [];
    let currentItem = null;
    
    for (const line of lines) {
      // Try to match line against inventory mappings
      const matchedMapping = mappings.find(mapping => 
        line.toLowerCase().includes(mapping.sanmarCode.toLowerCase()) ||
        line.toLowerCase().includes(mapping.description.toLowerCase())
      );
      
      if (matchedMapping) {
        if (currentItem) {
          lineItems.push(currentItem);
        }
        currentItem = {
          product: { id: matchedMapping.productId },
          quantity: 0,
          size: null,
          color: null,
          price: 0
        };
        continue;
      }
      
      currentItem = parseLineItemInfo(line, currentItem);
    }
    
    // Add final item if exists
    if (currentItem) {
      lineItems.push(currentItem);
    }
    
    // Validate extracted items
    const validItems = lineItems.filter(item => 
      item.product?.id && 
      item.quantity > 0 &&
      item.size
    );
    
    log(LOG_LEVELS.INFO, SERVICE_NAME, {
      action: 'parseLineItems',
      status: 'success',
      totalFound: lineItems.length,
      validItems: validItems.length
    });
    
    if (!validItems.length) {
      throw new PrintavoValidationError(
        'No valid line items found in text',
        [{ message: `Found ${lineItems.length} items but none were valid` }],
        { 
          code: ERROR_CODES.VALIDATION.INVALID_INPUT,
          action: 'parseLineItems',
          totalFound: lineItems.length 
        }
      );
    }
    
    return validItems;
    
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
      throw new PrintavoValidationError(
        'Failed to parse line items',
        [{ message: error.message }],
        { 
          code: ERROR_CODES.VALIDATION.INVALID_INPUT,
          action: 'parseLineItems',
          originalError: error.message 
        }
      );
  }
}

module.exports = {
  getLineItem,
  createLineItem,
  updateLineItem,
  deleteLineItem,
  parseLineItems,
  // Export constants for testing
  REGEX_PATTERNS
};

================
File: backend/services/ocrService.js
================
const { LOG_LEVELS, log } = require('../utils/logger');
const { PrintavoValidationError } = require('../utils/errorHandling');
const vision = require('@google-cloud/vision');
const { parseLineItems } = require('./lineItemService');

// Initialize Google Cloud Vision client
const client = new vision.ImageAnnotatorClient();

/**
 * Process an invoice image using OCR and extract line items
 * @param {string} base64Image Base64 encoded image data
 * @returns {Promise<Object>} Extracted invoice data including line items
 */
async function processInvoice(base64Image) {
  log(LOG_LEVELS.INFO, 'Processing invoice image with OCR');
  
  try {
    // Validate input
    if (!base64Image) {
      throw new PrintavoValidationError(
        'No image data provided',
        { details: 'base64Image parameter is required' }
      );
    }
    
    // Remove data URL prefix if present
    const imageData = base64Image.replace(/^data:image\/\w+;base64,/, '');
    
    // Perform OCR using Google Cloud Vision
    const [result] = await client.textDetection({
      image: { content: imageData }
    });
    
    const detections = result.textAnnotations;
    if (!detections || detections.length === 0) {
      throw new PrintavoValidationError(
        'No text detected in image',
        { details: 'The image may be blank or unreadable' }
      );
    }
    
    // Extract full text from OCR result
    const extractedText = detections[0].description;
    log(LOG_LEVELS.DEBUG, 'Extracted text from image', {
      textLength: extractedText.length,
      firstLine: extractedText.split('\n')[0]
    });
    
    // Parse line items from extracted text
    const lineItems = await parseLineItems(extractedText);
    
    // Extract invoice metadata (PO number, date, etc)
    const metadata = extractInvoiceMetadata(extractedText);
    
    return {
      success: true,
      lineItems,
      metadata,
      rawText: extractedText
    };
    
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoValidationError(
      'Failed to process invoice image',
      { originalError: error.message }
    );
  }
}

/**
 * Extract invoice metadata from OCR text
 * @param {string} text OCR extracted text
 * @returns {Object} Extracted metadata
 */
function extractInvoiceMetadata(text) {
  const metadata = {
    poNumber: null,
    orderDate: null,
    invoiceNumber: null,
    total: null
  };
  
  // Split into lines and clean
  const lines = text
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);
    
  for (const line of lines) {
    // Look for PO number
    const poMatch = line.match(/p\.?o\.?\s*#?\s*:?\s*(\w+[-\d]+)/i);
    if (poMatch && !metadata.poNumber) {
      metadata.poNumber = poMatch[1];
      continue;
    }
    
    // Look for order date
    const dateMatch = line.match(/date:?\s*(\d{1,2}[-/]\d{1,2}[-/]\d{2,4})/i);
    if (dateMatch && !metadata.orderDate) {
      metadata.orderDate = dateMatch[1];
      continue;
    }
    
    // Look for invoice number
    const invoiceMatch = line.match(/inv(oice)?\.?\s*#?\s*:?\s*(\w+[-\d]+)/i);
    if (invoiceMatch && !metadata.invoiceNumber) {
      metadata.invoiceNumber = invoiceMatch[2];
      continue;
    }
    
    // Look for total amount
    const totalMatch = line.match(/total:?\s*\$?\s*([\d,.]+)/i);
    if (totalMatch && !metadata.total) {
      metadata.total = parseFloat(totalMatch[1].replace(/,/g, ''));
      continue;
    }
  }
  
  return metadata;
}

module.exports = { processInvoice };

================
File: backend/services/openaiService.js
================
const OpenAI = require('openai');

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// System message to define the AI assistant's behavior
const SYSTEM_MESSAGE = {
  role: 'system',
  content: `You are a helpful AI assistant for a print shop using Printavo. You can help with:
1. Creating quotes and orders in Printavo
2. Processing and extracting information from invoices
3. Answering questions about orders and products
4. Providing information about SanMar products and inventory

Keep your responses concise and focused on helping the user with their print shop tasks.
When creating quotes, make sure to ask for all necessary information like customer email, product details, quantities, and sizes.`
};

async function generateResponse(userMessage, conversationHistory = []) {
  try {
    const messages = [
      SYSTEM_MESSAGE,
      ...conversationHistory,
      { role: 'user', content: userMessage }
    ];

    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages,
      temperature: 0.7,
      max_tokens: 500
    });

    return {
      reply: completion.choices[0].message.content,
      success: true
    };
  } catch (error) {
    console.error('OpenAI API Error:', error);
    return {
      reply: 'I apologize, but I encountered an error. Please try again.',
      success: false,
      error: error.message
    };
  }
}

module.exports = {
  generateResponse
};

================
File: backend/services/printavoService.js
================
/**
 * @fileoverview Printavo Service Facade
 * This module serves as the main entry point for all Printavo-related operations,
 * aggregating functionality from various specialized services into a single,
 * cohesive interface. It handles initialization of the GraphQL client and
 * provides access to all Printavo operations through a unified API.
 * 
 * @module printavoService
 * @version 1.0.0
 */

import graphqlClient from '../graphql/client.js';
import { 
  getInvoice, 
  getRecentInvoices, 
  createInvoice, 
  updateInvoice,
  deleteInvoice
} from './invoiceService.js';
import { 
  getAccount, 
  verifyConnection,
  getAccountUsers,
  getAccountStatuses,
  isCatalogEnabled
} from './accountService.js';
import { 
  findContacts,
  getContact,
  createContact,
  updateContact,
  deleteContact
} from './contactService.js';
import { 
  getPreSubmitInfo,
  submitPO
} from './sanmarService.js';
import { 
  processInvoice
} from './ocrService.js';
import { 
  parseLineItems
} from './lineItemService.js';
import { LOG_LEVELS, log } from '../utils/logger.js';
import { 
  PrintavoAPIError, 
  PrintavoValidationError, 
  PrintavoAuthenticationError,
  ERROR_CODES
} from '../utils/errorHandling.js';

const SERVICE_NAME = 'PrintavoService';

// Log service initialization
log(LOG_LEVELS.INFO, SERVICE_NAME, {
  action: 'initialize',
  message: 'Initializing Printavo service'
});

/**
 * @typedef {Object} PrintavoService
 * @property {Object} account - Account management operations
 * @property {function(): Promise<Object>} account.getAccount - Get account details
 * @property {function(): Promise<boolean>} account.verifyConnection - Verify API connection
 * @property {function(): Promise<Array<Object>>} account.getAccountUsers - Get account users
 * @property {function(): Promise<Array<Object>>} account.getAccountStatuses - Get account statuses
 * @property {function(): Promise<boolean>} account.isCatalogEnabled - Check if catalog is enabled
 * 
 * @property {Object} contacts - Contact management operations
 * @property {function(Object): Promise<Array<Object>>} contacts.findContacts - Search contacts
 * @property {function(string): Promise<Object>} contacts.getContact - Get contact by ID
 * @property {function(Object): Promise<Object>} contacts.createContact - Create new contact
 * @property {function(string, Object): Promise<Object>} contacts.updateContact - Update contact
 * @property {function(string): Promise<boolean>} contacts.deleteContact - Delete contact
 * 
 * @property {Object} invoices - Invoice management operations
 * @property {function(string): Promise<Object>} invoices.getInvoice - Get invoice by ID
 * @property {function(Object): Promise<Object>} invoices.getRecentInvoices - Get recent invoices
 * @property {function(Object): Promise<Object>} invoices.createInvoice - Create new invoice
 * @property {function(string, Object): Promise<Object>} invoices.updateInvoice - Update invoice
 * @property {function(string): Promise<boolean>} invoices.deleteInvoice - Delete invoice
 * 
 * @property {Object} sanmar - SanMar integration operations
 * @property {function(Object): Promise<Object>} sanmar.getPreSubmitInfo - Get pre-submission info
 * @property {function(Object): Promise<Object>} sanmar.submitPO - Submit purchase order
 * 
 * @property {Object} processing - OCR and line item processing operations
 * @property {function(string): Promise<Object>} processing.processInvoice - Process invoice OCR
 * @property {function(string): Promise<Array<Object>>} processing.parseLineItems - Parse line items
 * 
 * @property {Object} errors - Error handling utilities
 * @property {Class} errors.PrintavoAPIError - API error class
 * @property {Class} errors.PrintavoValidationError - Validation error class
 * @property {Class} errors.PrintavoAuthenticationError - Authentication error class
 * @property {Object} errors.ERROR_CODES - Standardized error codes
 * @property {Object} errors.ERROR_CODES.VALIDATION - Validation error codes
 * @property {Object} errors.ERROR_CODES.API - API error codes
 * @property {Object} errors.ERROR_CODES.DATA - Data error codes
 * @property {Object} errors.ERROR_CODES.SYSTEM - System error codes
 */

/**
 * Printavo service interface providing access to all Printavo operations
 * @type {PrintavoService}
 */
const printavoService = {
  // Account Management
  account: {
    getAccount,
    verifyConnection,
    getAccountUsers,
    getAccountStatuses,
    isCatalogEnabled
  },

  // Contact Management
  contacts: {
    findContacts,
    getContact,
    createContact,
    updateContact,
    deleteContact
  },

  // Invoice Management
  invoices: {
    getInvoice,
    getRecentInvoices,
    createInvoice,
    updateInvoice,
    deleteInvoice
  },

  // SanMar Integration
  sanmar: {
    getPreSubmitInfo,
    submitPO
  },

  // OCR and Line Item Processing
  processing: {
    processInvoice,
    parseLineItems
  },

  // Error Handling
  errors: {
    PrintavoAPIError,
    PrintavoValidationError,
    PrintavoAuthenticationError,
    ERROR_CODES
  }
};

// Export the service interface
export default printavoService;

================
File: backend/services/quoteService.js
================
const { LOG_LEVELS, log } = require('../utils/logger');
const { executeGraphQL, clientPromise } = require('../graphql/client');
const { validateQuoteInput } = require('../validation/utils');
const { PrintavoAPIError, PrintavoValidationError } = require('../utils/errorHandling');
const { SIZE_DISTRIBUTIONS, PRODUCT_DEFAULTS, IMPRINT_LOCATIONS } = require('../constants/productDefaults');

// Add product search query
const SEARCH_PRODUCT = `
  query SearchProduct($sku: String, $name: String) {
    products(
      first: 1,
      sku: $sku,
      searchTerm: $name
    ) {
      nodes {
        id
        name
        sku
        description
        category {
          id
          name
        }
        defaultPrice
        defaultMarkup
      }
    }
  }
`;

// Add contact history query
const GET_CONTACT_HISTORY = `
  query GetContactHistory($contactId: ID!) {
    contact(id: $contactId) {
      id
      recentOrders: orders(first: 1) {
        nodes {
          shippingAddress {
            companyName
            customerName
            address1
            address2
            city
            stateIso
            zipCode
            countryIso
          }
          paymentTerms {
            id
            name
          }
          deliveryMethod {
            id
            name
          }
        }
      }
    }
  }
`;

// Add contact search query
const SEARCH_CONTACT = `
  query SearchContact($email: String, $fullName: String) {
    contacts(
      first: 1,
      email: $email,
      searchTerm: $fullName
    ) {
      nodes {
        id
        email
        fullName
        phone
        company {
          id
          name
        }
      }
    }
  }
`;

// GraphQL queries
const GET_QUOTE = `
  query GetQuote($id: ID!) {
    quote(id: $id) {
      id
      visualId
      customerDueAt
      contact {
        id
        email
        fullName
        phone
        company {
          id
          name
        }
      }
      owner {
        id
        email
        firstName
        lastName
      }
      status {
        id
        name
        color
        type
        position
      }
      lineItemGroups {
        nodes {
          id
          name
          description
          position
          lineItems {
            nodes {
              id
              product {
                id
                name
                sku
                description
                category {
                  id
                  name
                }
              }
              quantity
              size
              color
              price
              cost
              markup
              profit
              mockups {
                nodes {
                  id
                  url
                  position
                }
              }
              imprints {
                nodes {
                  id
                  name
                  description
                  location
                  colors
                  mockupUrl
                }
              }
            }
          }
        }
      }
      shippingAddress {
        companyName
        customerName
        address1
        address2
        city
        stateIso
        zipCode
        countryIso
      }
      billingAddress {
        companyName
        customerName
        address1
        address2
        city
        stateIso
        zipCode
        countryIso
      }
      customerNote
      productionNote
      internalNote
      tags
      paymentStatus
      paymentProcessor
      paymentTerms {
        id
        name
        description
        daysUntilDue
      }
      deliveryMethod {
        id
        name
        description
      }
      approvals {
        nodes {
          id
          status
          requestedAt
          respondedAt
          mockupUrl
        }
      }
      subtotal
      tax
      shipping
      total
      balance
      depositRequired
      depositPaid
      timestamps {
        createdAt
        updatedAt
        deletedAt
        inProductionAt
        completedAt
      }
    }
  }
`;

const GET_RECENT_QUOTES = `
  query GetRecentQuotes(
    $first: Int
    $after: String
    $statusIds: [ID!]
    $inProductionAfter: ISO8601DateTime
    $inProductionBefore: ISO8601DateTime
    $paymentStatus: OrderPaymentStatus
    $sortOn: OrderSortField
    $sortDescending: Boolean
    $searchTerm: String
    $tags: [String!]
  ) {
    quotes(
      first: $first
      after: $after
      statusIds: $statusIds
      inProductionAfter: $inProductionAfter
      inProductionBefore: $inProductionBefore
      paymentStatus: $paymentStatus
      sortOn: $sortOn
      sortDescending: $sortDescending
      searchTerm: $searchTerm
      tags: $tags
    ) {
      nodes {
        id
        visualId
        customerDueAt
        contact {
          id
          email
          fullName
          company {
            id
            name
          }
        }
        status {
          id
          name
          color
          type
        }
        lineItemGroups {
          nodes {
            id
            name
            lineItems {
              nodes {
                id
                quantity
                size
                color
                price
                product {
                  id
                  name
                  sku
                }
              }
            }
          }
        }
        paymentStatus
        subtotal
        tax
        shipping
        total
        balance
        tags
        timestamps {
          createdAt
          updatedAt
          inProductionAt
          completedAt
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalNodes
    }
  }
`;

const CREATE_QUOTE = `
  mutation CreateQuote($input: QuoteCreateInput!) {
    quoteCreate(input: $input) {
      quote {
        id
        visualId
        customerDueAt
        contact {
          id
          email
          fullName
        }
        status {
          id
          name
          color
        }
        lineItemGroups {
          nodes {
            id
            name
            lineItems {
              nodes {
                id
                quantity
                size
                color
                price
                product {
                  id
                  name
                  sku
                }
              }
            }
          }
        }
        shippingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        billingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        customerNote
        productionNote
        internalNote
        tags
        paymentStatus
        paymentTerms {
          id
          name
        }
        deliveryMethod {
          id
          name
        }
        subtotal
        tax
        shipping
        total
        balance
        depositRequired
      }
      errors {
        message
        path
      }
    }
  }
`;

const UPDATE_QUOTE = `
  mutation UpdateQuote($id: ID!, $input: QuoteUpdateInput!) {
    quoteUpdate(id: $id, input: $input) {
      quote {
        id
        visualId
        customerDueAt
        contact {
          id
          email
          fullName
        }
        status {
          id
          name
          color
        }
        lineItemGroups {
          nodes {
            id
            name
            lineItems {
              nodes {
                id
                quantity
                size
                color
                price
                product {
                  id
                  name
                  sku
                }
              }
            }
          }
        }
        shippingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        billingAddress {
          companyName
          customerName
          address1
          address2
          city
          stateIso
          zipCode
          countryIso
        }
        customerNote
        productionNote
        internalNote
        tags
        paymentStatus
        paymentTerms {
          id
          name
        }
        deliveryMethod {
          id
          name
        }
        subtotal
        tax
        shipping
        total
        balance
        depositRequired
        depositPaid
      }
      errors {
        message
        path
      }
    }
  }
`;

const DELETE_QUOTE = `
  mutation DeleteQuote($id: ID!) {
    quoteDelete(id: $id) {
      success
      errors {
        message
        path
      }
    }
  }
`;

/**
 * Fetch a quote by ID
 * @param {string} quoteId - The quote ID
 * @returns {Promise<Object>} The quote data
 */
async function getQuote(quoteId) {
  log(LOG_LEVELS.INFO, 'Fetching quote', { quoteId });
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(GET_QUOTE, { id: quoteId });
    if (!data?.quote) {
      throw new PrintavoAPIError(
        'Quote not found',
        'NOT_FOUND_ERROR',
        { id: quoteId }
      );
    }
    return data.quote;
  } catch (error) {
    if (error instanceof PrintavoAPIError) {
      throw error;
    }
    throw new PrintavoAPIError(
      'Failed to fetch quote',
      'FETCH_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Fetch recent quotes with pagination and sorting
 * @param {Object} options Query options
 * @param {number} options.first - Number of quotes to fetch (max 25)
 * @param {string} options.after - Cursor for pagination
 * @param {Array<string>} options.statusIds - Filter by status IDs
 * @param {string} options.inProductionAfter - Filter by production start date
 * @param {string} options.inProductionBefore - Filter by production end date
 * @param {string} options.paymentStatus - Filter by payment status
 * @param {string} options.sortOn - Field to sort on
 * @param {boolean} options.sortDescending - Sort direction
 * @param {string} options.searchTerm - Search term for filtering
 * @param {Array<string>} options.tags - Filter by tags
 * @returns {Promise<Object>} The quotes data with pagination info
 */
async function getRecentQuotes(options = {}) {
  const {
    first = 25,
    after = null,
    statusIds = null,
    inProductionAfter = null,
    inProductionBefore = null,
    paymentStatus = null,
    sortOn = 'CREATED_AT',
    sortDescending = true,
    searchTerm = null,
    tags = null
  } = options;

  log(LOG_LEVELS.INFO, 'Fetching recent quotes', {
    first,
    after,
    statusIds,
    paymentStatus,
    sortOn
  });

  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(GET_RECENT_QUOTES, {
      first: Math.min(first, 25),
      after,
      statusIds,
      inProductionAfter,
      inProductionBefore,
      paymentStatus,
      sortOn,
      sortDescending,
      searchTerm,
      tags
    });

    if (!data?.quotes) {
      throw new PrintavoAPIError(
        'No quotes data returned',
        'FETCH_ERROR'
      );
    }

    return data.quotes;
  } catch (error) {
    throw new PrintavoAPIError(
      'Failed to fetch recent quotes',
      'FETCH_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Get size distribution based on product type and distribution name
 * @param {Object} product Product information
 * @param {string} distributionName Name of the distribution to use
 * @param {number} totalQuantity Total quantity to distribute
 * @returns {Object} Size distribution
 */
function getSizeDistribution(product, distributionName, totalQuantity) {
  // If specific distribution provided, use that
  if (distributionName && SIZE_DISTRIBUTIONS[distributionName]) {
    const distribution = SIZE_DISTRIBUTIONS[distributionName];
    const total = Object.values(distribution).reduce((sum, qty) => sum + qty, 0);
    
    // Scale the distribution to match total quantity
    return Object.fromEntries(
      Object.entries(distribution).map(([size, qty]) => [
        size,
        Math.round((qty / total) * totalQuantity)
      ])
    );
  }

  // Try to determine product type and use its default
  const productType = Object.entries(PRODUCT_DEFAULTS).find(([_, defaults]) =>
    product.name.toLowerCase().includes(_.toLowerCase())
  );

  if (productType) {
    const [_, defaults] = productType;
    return getSizeDistribution(product, defaults.defaultSizing, totalQuantity);
  }

  // Fallback to standard retail distribution
  return getSizeDistribution(product, 'STANDARD_RETAIL', totalQuantity);
}

/**
 * Get suggested imprint locations for a product
 * @param {Object} product Product information
 * @returns {Array} Suggested imprint locations
 */
function getSuggestedImprints(product) {
  // Try to determine product type
  const productType = Object.entries(PRODUCT_DEFAULTS).find(([_, defaults]) =>
    product.name.toLowerCase().includes(_.toLowerCase())
  );

  if (productType) {
    const [_, defaults] = productType;
    return defaults.commonLocations.map(location => ({
      name: location,
      ...IMPRINT_LOCATIONS[location]
    }));
  }

  // Fallback to basic front/back locations
  return ['Front Center', 'Back Center'].map(location => ({
    name: location,
    ...IMPRINT_LOCATIONS[location]
  }));
}

/**
 * Expand size distribution into individual line items
 * @param {Object} item Line item with size distribution
 * @returns {Array} Array of line items with individual sizes
 */
function expandSizeDistribution(item) {
  // If no sizeDistribution provided, return item as is
  if (!item.sizeDistribution && !item.standardSizing && !item.totalQuantity) {
    return [item];
  }

  let distribution;
  if (item.sizeDistribution) {
    distribution = item.sizeDistribution;
  } else if (item.totalQuantity) {
    // Will be populated after product lookup
    distribution = null;
  } else {
    return [item];
  }

  const items = [];
  if (distribution) {
    const sizes = Object.entries(distribution);
    
    // Create individual line items for each size
    for (const [size, quantity] of sizes) {
      if (quantity > 0) {
        items.push({
          ...item,
          size,
          quantity,
          sizeDistribution: undefined,
          standardSizing: undefined,
          totalQuantity: undefined
        });
      }
    }
  } else {
    // Keep the item but mark it for distribution after product lookup
    items.push({
      ...item,
      pendingDistribution: true
    });
  }

  return items;
}

/**
 * Calculate required deposit based on quote total
 * @param {Array} lineItems Enhanced line items with prices
 * @param {Object} contact Contact information for customer history
 * @returns {number} Recommended deposit amount
 */
async function calculateDepositRequired(lineItems, contact) {
  // Calculate subtotal from line items
  const subtotal = lineItems.reduce((sum, item) => {
    return sum + (item.price * item.quantity);
  }, 0);

  // Base deposit percentage on order size
  let depositPercentage = 0;
  if (subtotal <= 500) {
    depositPercentage = 0.5; // 50% for small orders
  } else if (subtotal <= 2000) {
    depositPercentage = 0.35; // 35% for medium orders
  } else {
    depositPercentage = 0.25; // 25% for large orders
  }

  // Round up to nearest $10
  const deposit = Math.ceil((subtotal * depositPercentage) / 10) * 10;

  log(LOG_LEVELS.INFO, 'Calculated deposit', {
    subtotal,
    depositPercentage,
    deposit
  });

  return deposit;
}

/**
 * Enhance line items with product lookups and defaults
 * @param {Array} lineItems Raw line items with product name/sku
 * @returns {Promise<Array>} Enhanced line items with product IDs and defaults
 */
async function enhanceLineItems(lineItems) {
  const enhanced = [];
  
  for (const item of lineItems) {
    // Handle size distribution first
    const expandedItems = expandSizeDistribution(item);
    
    for (const expandedItem of expandedItems) {
      // Skip if we already have product ID
      if (expandedItem.productId) {
        enhanced.push(expandedItem);
        continue;
      }

      // Look up product by SKU or name
      const productResult = await executeGraphQL(SEARCH_PRODUCT, {
        sku: expandedItem.sku,
        name: expandedItem.productName
      });

      const product = productResult?.products?.nodes?.[0];
      if (!product) {
        throw new PrintavoValidationError(
          'Product not found',
          { productInfo: { sku: expandedItem.sku, name: expandedItem.productName } }
        );
      }

      // Handle pending distribution now that we have product info
      let itemsToAdd = [];
      if (expandedItem.pendingDistribution) {
        const distribution = getSizeDistribution(
          product,
          expandedItem.standardSizing,
          expandedItem.totalQuantity
        );

        // Create items for each size
        for (const [size, quantity] of Object.entries(distribution)) {
          if (quantity > 0) {
            itemsToAdd.push({
              ...expandedItem,
              size,
              quantity,
              pendingDistribution: undefined,
              standardSizing: undefined,
              totalQuantity: undefined
            });
          }
        }
      } else {
        itemsToAdd = [expandedItem];
      }

      // Add product info and defaults to each item
      for (const item of itemsToAdd) {
        const enhancedItem = {
          ...item,
          productId: product.id,
          price: item.price || product.defaultPrice,
          markup: item.markup || product.defaultMarkup
        };

        // Add suggested imprints if none provided
        if (!enhancedItem.imprints || enhancedItem.imprints.length === 0) {
          enhancedItem.imprints = getSuggestedImprints(product);
        }

        enhanced.push(enhancedItem);

        log(LOG_LEVELS.INFO, 'Enhanced product line item', {
          productId: product.id,
          sku: product.sku,
          name: product.name,
          size: enhancedItem.size,
          quantity: enhancedItem.quantity
        });
      }
    }
  }

  return enhanced;
}

/**
 * Get smart defaults based on contact history
 * @param {string} contactId Contact ID
 * @returns {Promise<Object>} Default values for quote
 */
async function getSmartDefaults(contactId) {
  const historyResult = await executeGraphQL(GET_CONTACT_HISTORY, { contactId });
  const recentOrder = historyResult?.contact?.recentOrders?.nodes?.[0];

  if (!recentOrder) {
    return {};
  }

  return {
    shippingAddress: recentOrder.shippingAddress,
    paymentTerms: recentOrder.paymentTerms,
    deliveryMethod: recentOrder.deliveryMethod
  };
}

/**
 * Create a new quote
 * @param {Object} quoteData - The quote data
 * @returns {Promise<Object>} The created quote
 */
async function createQuote(quoteData) {
  log(LOG_LEVELS.INFO, 'Creating quote', {
    contactInfo: quoteData.contact || { id: quoteData.contactId },
    lineItemsCount: quoteData.lineItems?.length
  });
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    // Validate input data
    validateQuoteInput(quoteData);
    
    // If we don't have contactId, look up the contact
    let contactId = quoteData.contactId;
    if (!contactId && quoteData.contact) {
      const contactResult = await executeGraphQL(SEARCH_CONTACT, {
        email: quoteData.contact.email,
        fullName: quoteData.contact.fullName
      });
      
      const contact = contactResult?.contacts?.nodes?.[0];
      if (!contact) {
        throw new PrintavoValidationError(
          'Contact not found. Please create the contact first.',
          { contactInfo: quoteData.contact }
        );
      }
      contactId = contact.id;
      
      log(LOG_LEVELS.INFO, 'Found contact', { 
        contactId,
        email: contact.email,
        fullName: contact.fullName
      });
    }

    // Enhance line items with product lookups and size distribution
    const enhancedLineItems = await enhanceLineItems(quoteData.lineItems);

    // Get smart defaults from contact history
    const defaults = await getSmartDefaults(contactId);

    // Calculate deposit if not specified
    const depositRequired = quoteData.depositRequired ?? 
      await calculateDepositRequired(enhancedLineItems, defaults);
    
    // Prepare input data
    const input = {
      contact: { id: contactId },
      customerDueAt: quoteData.dueDate || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      lineItemGroups: [{
        lineItems: enhancedLineItems.map(item => ({
          product: { id: item.productId },
          quantity: item.quantity,
          size: item.size,
          color: item.color,
          price: item.price,
          markup: item.markup,
          imprints: item.imprints?.map(imp => ({
            name: imp.name,
            description: imp.description,
            location: imp.location,
            colors: imp.colors
          }))
        }))
      }],
      shippingAddress: quoteData.shippingAddress || defaults.shippingAddress,
      billingAddress: quoteData.billingAddress,
      customerNote: quoteData.customerNote,
      productionNote: quoteData.productionNote,
      internalNote: quoteData.internalNote,
      tags: quoteData.tags,
      status: quoteData.statusId ? { id: quoteData.statusId } : undefined,
      paymentTerms: quoteData.paymentTermsId ? 
        { id: quoteData.paymentTermsId } : 
        defaults.paymentTerms,
      deliveryMethod: quoteData.deliveryMethodId ? 
        { id: quoteData.deliveryMethodId } : 
        defaults.deliveryMethod,
      depositRequired
    };
    
    const data = await executeGraphQL(CREATE_QUOTE, { input });
    const response = data.quoteCreate;
    
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Quote creation failed',
        { errors: response.errors }
      );
    }
    
    return response.quote;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoAPIError(
      'Failed to create quote',
      'CREATE_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Update an existing quote
 * @param {string} id Quote ID
 * @param {Object} updateData Update data
 * @returns {Promise<Object>} Updated quote
 */
async function updateQuote(id, updateData) {
  log(LOG_LEVELS.INFO, 'Updating quote', { id });
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(UPDATE_QUOTE, {
      id,
      input: updateData
    });
    
    const response = data.quoteUpdate;
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Quote update failed',
        { errors: response.errors }
      );
    }
    
    return response.quote;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoAPIError(
      'Failed to update quote',
      'UPDATE_ERROR',
      { originalError: error.message }
    );
  }
}

/**
 * Delete a quote
 * @param {string} id Quote ID
 * @returns {Promise<boolean>} Success status
 */
async function deleteQuote(id) {
  log(LOG_LEVELS.INFO, 'Deleting quote', { id });
  
  try {
    // Wait for client initialization
    await clientPromise;
    
    const data = await executeGraphQL(DELETE_QUOTE, { id });
    
    const response = data.quoteDelete;
    if (response.errors?.length > 0) {
      throw new PrintavoValidationError(
        'Quote deletion failed',
        { errors: response.errors }
      );
    }
    
    return response.success;
  } catch (error) {
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoAPIError(
      'Failed to delete quote',
      'DELETE_ERROR',
      { originalError: error.message }
    );
  }
}

module.exports = {
  getQuote,
  getRecentQuotes,
  createQuote,
  updateQuote,
  deleteQuote
};

================
File: backend/services/sanmarService.js
================
/**
 * @fileoverview SanMar Service
 * Provides robust integration with SanMar's SOAP API, including
 * comprehensive validation, error handling, and retry logic
 */

import soapClient from './enhancedSoapClient.js';
import { LOG_LEVELS, log } from '../utils/logger.js';
import { SanMarAPIError, ERROR_CODES } from '../utils/errorHandling.js';
import { isCatalogEnabled } from './accountService.js';

/**
 * Validates line items for SanMar API requirements
 * @param {Array} lineItems Items to validate
 * @throws {SanMarAPIError} If validation fails
 * @private
 */
function validateLineItems(lineItems) {
  // Check array structure
  if (!Array.isArray(lineItems)) {
    throw new SanMarAPIError(
      'Line items must be an array',
      ERROR_CODES.VALIDATION.INVALID_FORMAT,
      { received: typeof lineItems }
    );
  }

  // Allow empty array for flexibility
  if (lineItems.length === 0) {
    return;
  }

  // Validate each line item
  lineItems.forEach((item, index) => {
    const errors = [];

    // Required fields
    if (!item.inventoryKey) {
      errors.push('Missing inventoryKey');
    } else if (typeof item.inventoryKey !== 'string') {
      errors.push('inventoryKey must be a string');
    }

    if (!item.quantity) {
      errors.push('Missing quantity');
    } else if (!Number.isInteger(item.quantity) || item.quantity < 1) {
      errors.push('quantity must be a positive integer');
    }

    if (!item.sizeIndex) {
      errors.push('Missing sizeIndex');
    } else if (!Number.isInteger(item.sizeIndex) || item.sizeIndex < 0) {
      errors.push('sizeIndex must be a non-negative integer');
    }

    // Optional fields with type validation
    if (item.warehouse && typeof item.warehouse !== 'string') {
      errors.push('warehouse must be a string when provided');
    }

    if (errors.length > 0) {
      throw new SanMarAPIError(
        'Invalid line item',
        ERROR_CODES.VALIDATION.INVALID_INPUT,
        { 
          itemIndex: index,
          errors: errors
        }
      );
    }
  });
}

/**
 * Validates shipping information
 * @param {Object} shippingInfo Shipping details
 * @throws {SanMarAPIError} If validation fails
 * @private
 */
function validateShippingInfo(shippingInfo) {
  const requiredFields = [
    'shipToName',
    'shipToAddress1',
    'shipToCity',
    'shipToState',
    'shipToZip'
  ];

  const errors = [];

  // Check required fields
  requiredFields.forEach(field => {
    if (!shippingInfo[field]) {
      errors.push(`Missing ${field}`);
    } else if (typeof shippingInfo[field] !== 'string') {
      errors.push(`${field} must be a string`);
    } else if (!shippingInfo[field].trim()) {
      errors.push(`${field} cannot be empty`);
    }
  });

  // Validate ZIP code format
  if (shippingInfo.shipToZip && 
      !/^\d{5}(-\d{4})?$/.test(shippingInfo.shipToZip)) {
    errors.push('Invalid ZIP code format');
  }

  // Validate state code
  if (shippingInfo.shipToState && 
      !/^[A-Z]{2}$/.test(shippingInfo.shipToState)) {
    errors.push('State must be a 2-letter code');
  }

  if (errors.length > 0) {
    throw new SanMarAPIError(
      'Invalid shipping information',
      ERROR_CODES.VALIDATION.INVALID_INPUT,
      { errors }
    );
  }
}

/**
 * Check inventory availability via SanMar's SOAP API
 * @param {Array} lineItems Example: [{ inventoryKey, quantity, sizeIndex, warehouse }]
 * @returns {Promise<Object>} PreSubmit information response
 */
async function getPreSubmitInfo(lineItems = []) {
  log(LOG_LEVELS.INFO, 'SanMarService', {
    action: 'getPreSubmitInfo',
    itemCount: lineItems.length
  });
  
  try {
    // Validate integration access
    const isEnabled = await isCatalogEnabled('sanmar');
    if (!isEnabled) {
      throw new SanMarAPIError(
        'SanMar integration is not enabled for this account',
        ERROR_CODES.API.FORBIDDEN
      );
    }

    // Validate line items (now allows empty arrays)
    validateLineItems(lineItems);
    
    // Handle empty line items case
    if (lineItems.length === 0) {
      return {
        PreSubmitResponse: {
          items: [],
          status: 'SUCCESS',
          message: 'No items to check'
        }
      };
    }

    // Prepare request
    const request = {
      PreSubmitRequest: {
        items: lineItems.map(item => ({
          inventoryKey: item.inventoryKey,
          quantity: item.quantity,
          sizeIndex: item.sizeIndex,
          warehouse: item.warehouse
        }))
      }
    };

    // Execute request with enhanced client
    const result = await soapClient.execute('getPreSubmitInfo', request);

    // Validate response structure
    if (!result.PreSubmitResponse || !Array.isArray(result.PreSubmitResponse.items)) {
      throw new SanMarAPIError(
        'Invalid response structure from SanMar API',
        ERROR_CODES.API.SERVICE_UNAVAILABLE
      );
    }

    return result;
  } catch (error) {
    // Re-throw SanMarAPIError instances
    if (error instanceof SanMarAPIError) {
      throw error;
    }

    // Wrap other errors
    throw new SanMarAPIError(
      'Failed to get inventory information',
      ERROR_CODES.SYSTEM.DEPENDENCY,
      { originalError: error.message }
    );
  }
}

/**
 * Submit purchase order to SanMar
 * @param {Object} orderData Order details including poNumber, shipping info, and lineItems
 * @returns {Promise<Object>} Order submission response
 */
async function submitPO(orderData) {
  log(LOG_LEVELS.INFO, 'SanMarService', {
    action: 'submitPO',
    poNumber: orderData.poNumber,
    itemCount: orderData.lineItems?.length
  });
  
  try {
    // Validate integration access
    const isEnabled = await isCatalogEnabled('sanmar');
    if (!isEnabled) {
      throw new SanMarAPIError(
        'SanMar integration is not enabled for this account',
        ERROR_CODES.API.FORBIDDEN
      );
    }

    // Validate PO number
    if (!orderData.poNumber || typeof orderData.poNumber !== 'string' || 
        !orderData.poNumber.trim()) {
      throw new SanMarAPIError(
        'Invalid purchase order number',
        ERROR_CODES.VALIDATION.INVALID_INPUT
      );
    }

    // Validate line items and shipping info
    validateLineItems(orderData.lineItems);
    validateShippingInfo(orderData);

    // Prevent empty orders
    if (orderData.lineItems.length === 0) {
      throw new SanMarAPIError(
        'Cannot submit empty purchase order',
        ERROR_CODES.VALIDATION.INVALID_INPUT
      );
    }
    
    // Prepare request
    const request = {
      PORequest: {
        header: {
          poNumber: orderData.poNumber,
          shipToName: orderData.shipToName,
          shipToAddress1: orderData.shipToAddress1,
          shipToAddress2: orderData.shipToAddress2 || '',
          shipToCity: orderData.shipToCity,
          shipToState: orderData.shipToState,
          shipToZip: orderData.shipToZip,
          shipToCountry: orderData.shipToCountry || 'USA'
        },
        lineItems: orderData.lineItems.map(item => ({
          inventoryKey: item.inventoryKey,
          quantity: item.quantity,
          sizeIndex: item.sizeIndex,
          warehouse: item.warehouse
        }))
      }
    };

    // Execute request with enhanced client
    const result = await soapClient.execute('submitPO', request);

    // Validate response structure
    if (!result.POResponse || !result.POResponse.confirmationNumber) {
      throw new SanMarAPIError(
        'Invalid response structure from SanMar API',
        ERROR_CODES.API.SERVICE_UNAVAILABLE
      );
    }

    return result;
  } catch (error) {
    // Re-throw SanMarAPIError instances
    if (error instanceof SanMarAPIError) {
      throw error;
    }

    // Wrap other errors
    throw new SanMarAPIError(
      'Failed to submit purchase order',
      ERROR_CODES.SYSTEM.DEPENDENCY,
      { originalError: error.message }
    );
  }
}

/**
 * Get status of a submitted PO
 * @param {string} poNumber Purchase order number
 * @returns {Promise<Object>} PO status and details
 */
async function getPOStatus(poNumber) {
  log(LOG_LEVELS.INFO, 'SanMarService', {
    action: 'getPOStatus',
    poNumber
  });
  
  try {
    // Validate integration access
    const isEnabled = await isCatalogEnabled('sanmar');
    if (!isEnabled) {
      throw new SanMarAPIError(
        'SanMar integration is not enabled for this account',
        ERROR_CODES.API.FORBIDDEN
      );
    }

    // Validate PO number
    if (!poNumber || typeof poNumber !== 'string' || !poNumber.trim()) {
      throw new SanMarAPIError(
        'Invalid purchase order number',
        ERROR_CODES.VALIDATION.INVALID_INPUT
      );
    }
    
    // Prepare request
    const request = {
      POStatusRequest: {
        poNumber: poNumber.trim()
      }
    };

    // Execute request with enhanced client
    const result = await soapClient.execute('getPOStatus', request);

    // Validate response structure
    if (!result.POStatusResponse || !result.POStatusResponse.status) {
      throw new SanMarAPIError(
        'Invalid response structure from SanMar API',
        ERROR_CODES.API.SERVICE_UNAVAILABLE
      );
    }

    return result;
  } catch (error) {
    // Re-throw SanMarAPIError instances
    if (error instanceof SanMarAPIError) {
      throw error;
    }

    // Wrap other errors
    throw new SanMarAPIError(
      'Failed to get PO status',
      ERROR_CODES.SYSTEM.DEPENDENCY,
      { originalError: error.message }
    );
  }
}

export {
  getPreSubmitInfo,
  submitPO,
  getPOStatus
};

================
File: backend/tests/testConnections.js
================
/**
 * @fileoverview Connection Test Script
 * Tests connections to both Printavo and SanMar APIs
 * 
 * Usage: node tests/testConnections.js
 */

import printavoService from '../services/printavoService.js';
import { getPreSubmitInfo, getPOStatus } from '../services/sanmarService.js';
import { validatePrintavoEnv, validateSanMarEnv, loadSanMarConfig } from '../utils/envValidation.js';
import { LOG_LEVELS, log } from '../utils/logger.js';
import { SanMarAPIError, ERROR_CODES } from '../utils/errorHandling.js';

async function testPrintavoConnection() {
  console.log('\n Testing Printavo Connection...');
  
  try {
    // Validate environment variables
    await validatePrintavoEnv();
    console.log(' Environment variables validated');

    // Test API connection
    const result = await printavoService.account.verifyConnection();
    if (result) {
      console.log(' Successfully connected to Printavo API');
      
      // Get additional account info
      const account = await printavoService.account.getAccount();
      console.log(' Account Details:');
      console.log(`   Name: ${account.name}`);
      console.log(`   Email: ${account.email}`);
      console.log(`   Subscription: ${account.subscription?.plan || 'N/A'}`);
    }
  } catch (error) {
    console.error(' Printavo Connection Failed:');
    console.error(`   Error: ${error.message}`);
    if (error.metadata) {
      console.error('   Additional Info:', error.metadata);
    }
    if (process.env.NODE_ENV === 'development') {
      console.error('\nStack Trace:', error.stack);
    }
    process.exitCode = 1;
  }
}

async function testSanMarConnection() {
  console.log('\n Testing SanMar Connection...');
  
  try {
    // Test environment validation
    await validateSanMarEnv();
    console.log(' Environment variables validated');

    // Test config loading
    const config = loadSanMarConfig();
    console.log(' Configuration loaded successfully');

    // Test WSSecurity setup
    console.log('\n Testing SOAP Authentication...');
    
    // Test with empty line items (should handle gracefully)
    console.log('\n Testing empty line items handling...');
    const emptyResult = await getPreSubmitInfo([]);
    if (emptyResult.PreSubmitResponse.items.length === 0) {
      console.log(' Empty line items handled correctly');
    }

    // Test with valid line items
    console.log('\n Testing inventory check...');
    const testLineItems = [{
      inventoryKey: 'K100',  // Common SanMar product
      quantity: 1,
      sizeIndex: 0
    }];

    const result = await getPreSubmitInfo(testLineItems);
    if (result.PreSubmitResponse && Array.isArray(result.PreSubmitResponse.items)) {
      console.log(' Successfully retrieved inventory information');
      console.log(' Response Details:');
      console.log(`   Items checked: ${result.PreSubmitResponse.items.length}`);
    }

    // Test invalid credentials (should fail gracefully)
    console.log('\n Testing error handling...');
    try {
      const invalidItems = [{
        inventoryKey: 'INVALID_KEY',
        quantity: -1,  // Invalid quantity
        sizeIndex: 0
      }];
      await getPreSubmitInfo(invalidItems);
    } catch (error) {
      if (error instanceof SanMarAPIError && 
          error.code === ERROR_CODES.VALIDATION.INVALID_INPUT) {
        console.log(' Invalid input handled correctly');
      } else {
        throw error;
      }
    }

    // Test PO status check with invalid PO (should fail gracefully)
    try {
      await getPOStatus('INVALID_PO');
    } catch (error) {
      if (error instanceof SanMarAPIError) {
        console.log(' Invalid PO number handled correctly');
      } else {
        throw error;
      }
    }

    console.log('\n All SanMar API tests completed successfully');
    
  } catch (error) {
    console.error(' SanMar Connection Failed:');
    console.error(`   Error: ${error.message}`);
    
    if (error instanceof SanMarAPIError) {
      console.error(`   Error Code: ${error.code}`);
      if (error.code === ERROR_CODES.VALIDATION.INVALID_CREDENTIALS) {
        console.error('   Hint: Check your SANMAR_USERNAME and SANMAR_PASSWORD');
      } else if (error.code === ERROR_CODES.SYSTEM.CONFIGURATION) {
        console.error('   Hint: Verify your SANMAR_WSDL_URL');
      }
    }
    
    if (error.metadata) {
      console.error('   Additional Info:', error.metadata);
    }
    
    if (process.env.NODE_ENV === 'development') {
      console.error('\nStack Trace:', error.stack);
    }
    
    process.exitCode = 1;
  }
}

async function runTests() {
  console.log(' Starting API Connection Tests...');
  
  try {
    await testPrintavoConnection();
    await testSanMarConnection();
    
    if (process.exitCode === 1) {
      console.log('\n Some tests failed. Please check the errors above.');
    } else {
      console.log('\n All connection tests passed successfully!');
      console.log('\n Test Summary:');
      console.log('   - Environment variables validated');
      console.log('   - SOAP authentication verified');
      console.log('   - Empty line items handling confirmed');
      console.log('   - Inventory check successful');
      console.log('   - Error handling verified');
    }
  } catch (error) {
    console.error('\n Test execution failed:', error);
    process.exitCode = 1;
  }
}

// Run tests if this script is executed directly
if (import.meta.url === new URL(import.meta.url).href) {
  runTests().catch(error => {
    console.error('Fatal error:', error);
    process.exitCode = 1;
  });
}

export {
  testPrintavoConnection,
  testSanMarConnection,
  runTests
};

================
File: backend/tests/testPrintavoConnection.js
================
require('dotenv').config();
const { verifyConnection, findContactByEmail, getAccount, initializeClient } = require('../services/printavoService');

async function testConnection() {
  await initializeClient();
  console.log('Testing Printavo API connection...');
  
  try {
    // Test 1: Verify basic connection
    console.log('\n1. Testing API connection...');
    const isConnected = await verifyConnection();
    console.log(' Connection successful');

    // Test 2: Get account info
    console.log('\n2. Fetching account information...');
    const account = await getAccount();
    console.log(' Account info retrieved:', {
      id: account.id,
      name: account.name
    });

    // Test 3: Search for a contact
    console.log('\n3. Testing contact search...');
    const testEmail = process.env.PRINTAVO_EMAIL;
    const contact = await findContactByEmail(testEmail);
    if (contact) {
      console.log(' Contact found:', {
        id: contact.id,
        fullName: contact.fullName,
        email: contact.email
      });
    } else {
      console.log(' No contact found with email:', testEmail);
    }

    console.log('\nAll tests completed successfully! ');
  } catch (error) {
    console.error('\n Test failed:', {
      name: error.name,
      message: error.message,
      code: error.code,
      details: error.details
    });
    process.exit(1);
  }
}

testConnection();

================
File: backend/utils/envValidation.js
================
/**
 * @fileoverview Environment Variable Validation Utility
 * Provides robust validation and parsing of environment variables
 */

import { PrintavoValidationError, SanMarAPIError, ERROR_CODES } from './errorHandling.js';

/**
 * Validates required environment variables
 * @param {string[]} requiredVars Array of required environment variable names
 * @param {string} context Service context for error messages
 * @throws {PrintavoValidationError|SanMarAPIError} If any required variables are missing
 */
function validateRequiredEnvVars(requiredVars, context) {
  const missing = requiredVars.filter(varName => !process.env[varName]);
  
  if (missing.length > 0) {
    const ErrorClass = context === 'SanMar' ? SanMarAPIError : PrintavoValidationError;
    const errorCode = context === 'SanMar' ? ERROR_CODES.SYSTEM.CONFIGURATION : 'ENV_VALIDATION_ERROR';
    
    throw new ErrorClass(
      `Missing required environment variables for ${context}: ${missing.join(', ')}`,
      errorCode,
      { missingVars: missing }
    );
  }
}

/**
 * Validates URL format
 * @param {string} url URL to validate
 * @param {string} varName Environment variable name for error context
 * @param {string} context Service context for error messages
 * @throws {PrintavoValidationError|SanMarAPIError} If URL is invalid
 */
function validateUrlFormat(url, varName, context) {
  try {
    new URL(url);
  } catch (error) {
    const ErrorClass = context === 'SanMar' ? SanMarAPIError : PrintavoValidationError;
    const errorCode = context === 'SanMar' ? ERROR_CODES.VALIDATION.INVALID_FORMAT : 'ENV_VALIDATION_ERROR';
    
    throw new ErrorClass(
      `Invalid ${varName} format`,
      errorCode,
      { variable: varName, value: url }
    );
  }
}

/**
 * Validates Printavo environment configuration
 * @throws {PrintavoValidationError} If validation fails
 */
function validatePrintavoEnv() {
  const requiredVars = [
    'PRINTAVO_API_URL',
    'PRINTAVO_ACCESS_TOKEN',
    'PRINTAVO_EMAIL'
  ];

  validateRequiredEnvVars(requiredVars, 'Printavo');

  // Validate URL format
  validateUrlFormat(process.env.PRINTAVO_API_URL, 'PRINTAVO_API_URL', 'Printavo');

  // Validate token format (basic format check)
  if (!/^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*$/.test(process.env.PRINTAVO_ACCESS_TOKEN)) {
    throw new PrintavoValidationError(
      'Invalid PRINTAVO_ACCESS_TOKEN format',
      'ENV_VALIDATION_ERROR',
      { variable: 'PRINTAVO_ACCESS_TOKEN' }
    );
  }

  // Validate email format
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(process.env.PRINTAVO_EMAIL)) {
    throw new PrintavoValidationError(
      'Invalid PRINTAVO_EMAIL format',
      'ENV_VALIDATION_ERROR',
      { variable: 'PRINTAVO_EMAIL' }
    );
  }
}

/**
 * Validates SanMar environment configuration
 * @throws {SanMarAPIError} If validation fails
 */
function validateSanMarEnv() {
  const requiredVars = [
    'SANMAR_WSDL_URL',
    'SANMAR_USERNAME',
    'SANMAR_PASSWORD'
  ];

  validateRequiredEnvVars(requiredVars, 'SanMar');

  // Validate WSDL URL format
  validateUrlFormat(process.env.SANMAR_WSDL_URL, 'SANMAR_WSDL_URL', 'SanMar');

  // Validate username format and content
  const username = process.env.SANMAR_USERNAME.trim();
  if (!username) {
    throw SanMarAPIError.configError(
      'SANMAR_USERNAME cannot be empty',
      { variable: 'SANMAR_USERNAME' }
    );
  }
  
  // Additional username validation (if required by SanMar)
  if (!/^[A-Za-z0-9_-]+$/.test(username)) {
    throw SanMarAPIError.configError(
      'SANMAR_USERNAME contains invalid characters',
      { 
        variable: 'SANMAR_USERNAME',
        details: 'Username must contain only letters, numbers, underscores, and hyphens'
      }
    );
  }

  // Validate password requirements
  const password = process.env.SANMAR_PASSWORD;
  if (password.length < 8) {
    throw SanMarAPIError.configError(
      'SANMAR_PASSWORD must be at least 8 characters',
      { 
        variable: 'SANMAR_PASSWORD',
        details: 'Minimum length requirement not met'
      }
    );
  }

  // Additional password strength validation
  if (!/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d\W_]{8,}$/.test(password)) {
    throw SanMarAPIError.configError(
      'SANMAR_PASSWORD does not meet complexity requirements',
      { 
        variable: 'SANMAR_PASSWORD',
        details: 'Password must contain at least one letter and one number'
      }
    );
  }
}

/**
 * Loads and validates all required environment variables
 * @returns {Object} Validated environment variables
 * @throws {SanMarAPIError} If validation fails
 */
function loadSanMarConfig() {
  validateSanMarEnv();

  return {
    wsdlUrl: process.env.SANMAR_WSDL_URL,
    username: process.env.SANMAR_USERNAME.trim(),
    password: process.env.SANMAR_PASSWORD
  };
}

export {
  validatePrintavoEnv,
  validateSanMarEnv,
  validateRequiredEnvVars,
  loadSanMarConfig
};

================
File: backend/utils/errorHandler.js
================
class AppError extends Error {
  constructor(message, statusCode, code) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
  }
}

function handleError(err, res) {
  const statusCode = err.statusCode || 500;
  const code = err.code || 'UNKNOWN_ERROR';
  
  res.status(statusCode).json({
    success: false,
    error: err.message,
    code,
    details: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
}

module.exports = { AppError, handleError };

================
File: backend/utils/errorHandling.js
================
import { LOG_LEVELS, log } from './logger.js';

class BaseError extends Error {
  constructor(message, name, statusCode, code, metadata = {}) {
    super(message);
    this.name = name;
    this.statusCode = statusCode;
    this.code = code;
    this.metadata = metadata;
    this.timestamp = new Date().toISOString();
    
    // Preserve stack trace
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      metadata: this.metadata,
      timestamp: this.timestamp
    };
  }

  logError(service) {
    log(LOG_LEVELS.ERROR, service, {
      error: this.toJSON(),
      stack: this.stack
    });
  }
}

class PrintavoAPIError extends BaseError {
  constructor(message, code = 'PRINTAVO_API_ERROR', metadata = {}, statusCode = 500) {
    super(message, 'PrintavoAPIError', statusCode, code, metadata);
  }
}

class PrintavoValidationError extends BaseError {
  constructor(message, validationErrors = [], metadata = {}) {
    super(
      message,
      'PrintavoValidationError',
      400,
      'VALIDATION_ERROR',
      {
        ...metadata,
        validationErrors: Array.isArray(validationErrors) ? validationErrors : [validationErrors]
      }
    );
  }
}

class PrintavoAuthenticationError extends BaseError {
  constructor(message, code = 'PRINTAVO_AUTH_ERROR', metadata = {}, statusCode = 401) {
    super(message, 'PrintavoAuthenticationError', statusCode, code, metadata);
  }
}

class SanMarAPIError extends BaseError {
  constructor(message, code = ERROR_CODES.API.SERVICE_UNAVAILABLE, metadata = {}, statusCode = 500) {
    // Adjust status code based on error code
    if (code === ERROR_CODES.API.UNAUTHORIZED) statusCode = 401;
    if (code === ERROR_CODES.API.FORBIDDEN) statusCode = 403;
    if (code === ERROR_CODES.VALIDATION.INVALID_CREDENTIALS) statusCode = 401;
    
    super(message, 'SanMarAPIError', statusCode, code, metadata);
  }

  /**
   * Creates an authentication error instance
   * @param {string} message Error message
   * @param {Object} metadata Additional error context
   * @returns {SanMarAPIError}
   */
  static authError(message, metadata = {}) {
    return new SanMarAPIError(
      message,
      ERROR_CODES.API.UNAUTHORIZED,
      metadata,
      401
    );
  }

  /**
   * Creates a WSSecurity error instance
   * @param {string} message Error message
   * @param {Object} metadata Additional error context
   * @returns {SanMarAPIError}
   */
  static wsSecurityError(message, metadata = {}) {
    return new SanMarAPIError(
      message,
      ERROR_CODES.VALIDATION.INVALID_CREDENTIALS,
      {
        ...metadata,
        errorType: 'WSSecurity'
      },
      401
    );
  }

  /**
   * Creates a configuration error instance
   * @param {string} message Error message
   * @param {Object} metadata Additional error context
   * @returns {SanMarAPIError}
   */
  static configError(message, metadata = {}) {
    return new SanMarAPIError(
      message,
      ERROR_CODES.SYSTEM.CONFIGURATION,
      metadata,
      500
    );
  }
}

/**
 * Centralized error handler middleware
 * @param {Error} err - Error object
 * @param {import('express').Request} req - Express request object
 * @param {import('express').Response} res - Express response object
 * @param {import('express').NextFunction} next - Express next function
 */
function handleError(err, req, res, next) {
  // Log error with request context
  const errorContext = {
    url: req.originalUrl,
    method: req.method,
    requestId: req.id, // Assuming request ID middleware
    userId: req.user?.id, // If authentication is used
    ip: req.ip,
    userAgent: req.get('user-agent')
  };

  // Handle known error types
  if (err instanceof BaseError) {
    err.logError('API');
    
    return res.status(err.statusCode).json({
      error: {
        message: err.message,
        code: err.code,
        timestamp: err.timestamp,
        ...(process.env.NODE_ENV === 'development' && {
          metadata: err.metadata,
          stack: err.stack
        })
      }
    });
  }

  // Handle unknown errors
  const unknownError = new BaseError(
    'Internal Server Error',
    'UnknownError',
    500,
    'INTERNAL_ERROR',
    { originalError: err.message }
  );
  
  unknownError.logError('API');

  // In production, don't send error details to client
  res.status(500).json({
    error: {
      message: 'Internal Server Error',
      code: 'INTERNAL_ERROR',
      timestamp: unknownError.timestamp
    }
  });
}

// Error code constants
const ERROR_CODES = {
  VALIDATION: {
    INVALID_INPUT: 'INVALID_INPUT',
    REQUIRED_FIELD: 'REQUIRED_FIELD',
    INVALID_FORMAT: 'INVALID_FORMAT',
    INVALID_CREDENTIALS: 'INVALID_CREDENTIALS'
  },
  API: {
    NOT_FOUND: 'NOT_FOUND',
    UNAUTHORIZED: 'UNAUTHORIZED',
    FORBIDDEN: 'FORBIDDEN',
    RATE_LIMITED: 'RATE_LIMITED',
    SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE'
  },
  DATA: {
    NOT_FOUND: 'DATA_NOT_FOUND',
    ALREADY_EXISTS: 'DATA_ALREADY_EXISTS',
    INVALID_STATE: 'INVALID_STATE'
  },
  SYSTEM: {
    CONFIGURATION: 'CONFIGURATION_ERROR',
    DEPENDENCY: 'DEPENDENCY_ERROR',
    NETWORK: 'NETWORK_ERROR',
    WSSECURITY: 'WSSECURITY_ERROR'
  }
};

export {
  BaseError,
  PrintavoAPIError,
  PrintavoValidationError,
  SanMarAPIError,
  handleError,
  ERROR_CODES,
  PrintavoAuthenticationError
};

================
File: backend/utils/fileUtils.js
================
const fs = require('fs').promises;
const path = require('path');

async function cleanupFiles(files) {
  // Move cleanupFiles function here
}

async function validatePDF(filePath) {
  // Move validatePDF function here
}

module.exports = { cleanupFiles, validatePDF };

================
File: backend/utils/logger.js
================
import debug from 'debug';
import util from 'util';

export const LOG_LEVELS = {
  ERROR: 'ERROR',
  WARN: 'WARN',
  INFO: 'INFO',
  DEBUG: 'DEBUG',
  TRACE: 'TRACE'
};

// Create debug instances for different log levels
const debugError = debug('app:error');
const debugWarn = debug('app:warn');
const debugInfo = debug('app:info');
const debugDebug = debug('app:debug');
const debugTrace = debug('app:trace');

/**
 * Formats the log message with timestamp and service name
 * @param {string} level - Log level
 * @param {string} service - Service name
 * @param {string|Object|Error} message - Message to log
 * @returns {string} Formatted log message
 */
function formatLogMessage(level, service, message) {
  const timestamp = new Date().toISOString();
  let formattedMessage = message;

  if (message instanceof Error) {
    formattedMessage = message.stack || message.message;
  } else if (typeof message === 'object') {
    formattedMessage = util.inspect(message, { depth: null, colors: true });
  }

  return `[${timestamp}] [${level}] [${service}] ${formattedMessage}`;
}

/**
 * Centralized logging function
 * @param {string} level - Log level from LOG_LEVELS
 * @param {string} service - Name of the service logging the message
 * @param {string|Object|Error} message - Message or object to log
 */
export function log(level, service, message) {
  const formattedMessage = formatLogMessage(level, service, message);

  switch (level) {
    case LOG_LEVELS.ERROR:
      console.error(formattedMessage);
      debugError(formattedMessage);
      break;
    case LOG_LEVELS.WARN:
      console.warn(formattedMessage);
      debugWarn(formattedMessage);
      break;
    case LOG_LEVELS.INFO:
      console.info(formattedMessage);
      debugInfo(formattedMessage);
      break;
    case LOG_LEVELS.DEBUG:
      debugDebug(formattedMessage);
      break;
    case LOG_LEVELS.TRACE:
      debugTrace(formattedMessage);
      break;
    default:
      console.log(formattedMessage);
      debugInfo(formattedMessage);
  }
}

================
File: backend/utils/ocrUtils.js
================
const Tesseract = require('tesseract.js');
const path = require('path');

async function performOCR(imagePath) {
  // Move performOCR function here
}

function combineOCRResults(results) {
  // Move combineOCRResults function here
}

module.exports = { performOCR, combineOCRResults };

================
File: backend/utils/pdfUtils.js
================
const pdf2img = require('pdf2img');
const path = require('path');

async function convertPDFToImages(pdfPath) {
  // Move convertPDFToImages function here
}

module.exports = { convertPDFToImages };

================
File: backend/validation/utils.js
================
const { 
  invoiceInputSchema, 
  searchCriteriaSchema 
} = require('./schemas');

const LOG_LEVELS = require('../utils/logger').LOG_LEVELS;
const log = require('../utils/logger').log;
const { PrintavoValidationError, ERROR_CODES } = require('../utils/errorHandling');

const SERVICE_NAME = 'ValidationService';

/**
 * Validates a zip code format
 * @param {string} zipCode - The zip code to validate
 * @returns {boolean} True if valid, false otherwise
 */
function validateZipCode(zipCode) {
  const zipRegex = /^\d{5}(-\d{4})?$/;
  return zipRegex.test(zipCode);
}

/**
 * Validates a price value
 * @param {number} price - The price to validate
 * @returns {boolean} True if valid, false otherwise
 */
function validatePrice(price) {
  return typeof price === 'number' && price >= 0;
}

/**
 * Validates a quantity value
 * @param {number} quantity - The quantity to validate
 * @returns {boolean} True if valid, false otherwise
 */
function validateQuantity(quantity) {
  return Number.isInteger(quantity) && quantity > 0;
}

/**
 * Validates a status ID format
 * @param {string} statusId - The status ID to validate
 * @returns {boolean} True if valid, false otherwise
 */
function validateStatusId(statusId) {
  return typeof statusId === 'string' && statusId.length > 0;
}

/**
 * Validates a string against a regex pattern
 * @param {string} value - The value to validate
 * @param {RegExp} pattern - The pattern to validate against
 * @returns {boolean} True if valid, false otherwise
 */
function validateWithRegex(value, pattern) {
  return pattern.test(value);
}

/**
 * Validates if a string is a valid date
 * @param {string} dateStr - The date string to validate
 * @returns {boolean} True if valid, false otherwise
 */
function isValidDate(dateStr) {
  const date = new Date(dateStr);
  return date instanceof Date && !isNaN(date);
}

/**
 * Validates invoice input data
 * @param {Object} invoiceData - The invoice data to validate
 * @throws {PrintavoValidationError} If validation fails
 */
function validateInvoiceInput(invoiceData) {
  try {
    log(LOG_LEVELS.DEBUG, 'Validating invoice input data');
    const validatedData = invoiceInputSchema.parse(invoiceData);

    // Additional custom validations
    if (validatedData.shippingAddress?.zipCode && !validateZipCode(validatedData.shippingAddress.zipCode)) {
      throw new PrintavoValidationError(
        'Invalid zip code format',
        { field: 'shippingAddress.zipCode' },
        { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
      );
    }

    validatedData.lineItems.forEach((item, index) => {
      if (item.price && !validatePrice(item.price)) {
        throw new PrintavoValidationError(
          `Invalid price for line item ${index}`,
          { field: `lineItems[${index}].price` },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
      if (!validateQuantity(item.quantity)) {
        throw new PrintavoValidationError(
          `Invalid quantity for line item ${index}`,
          { field: `lineItems[${index}].quantity` },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
    });

    log(LOG_LEVELS.DEBUG, SERVICE_NAME, {
      action: 'validateInvoiceInput',
      status: 'success'
    });
  } catch (error) {
    log(LOG_LEVELS.ERROR, SERVICE_NAME, {
      action: 'validateInvoiceInput',
      status: 'failed',
      error: error.message,
      stack: error.stack
    });
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoValidationError(
      'Invalid invoice data',
      error.errors || [{ message: error.message }],
      { 
        code: ERROR_CODES.VALIDATION.INVALID_INPUT,
        originalError: error.message 
      }
    );
  }
}

/**
 * Validates quote input data
 * @param {Object} quoteData - The quote data to validate
 * @throws {PrintavoValidationError} If validation fails
 */
function validateQuoteInput(quoteData) {
  try {
    log(LOG_LEVELS.DEBUG, 'Validating quote input data');

    // Required fields - either contactId or contact lookup info
    if (!quoteData.contactId && !quoteData.contact) {
      throw new PrintavoValidationError(
        'Either contactId or contact information (email/name) is required',
        { field: 'contact' },
        { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }

    // If contact info provided instead of ID, validate it
    if (quoteData.contact) {
      if (!quoteData.contact.email && !quoteData.contact.fullName) {
        throw new PrintavoValidationError(
          'Either email or full name is required for contact lookup',
          { field: 'contact' },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      // Validate email format if provided
      if (quoteData.contact.email && !validateWithRegex(quoteData.contact.email, /^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        throw new PrintavoValidationError(
          'Invalid email format',
          { field: 'contact.email' },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
    }

    if (!quoteData.lineItems || !Array.isArray(quoteData.lineItems) || quoteData.lineItems.length === 0) {
      throw new PrintavoValidationError(
        'At least one line item is required',
        { field: 'lineItems' },
        { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
      );
    }

    // Validate each line item
    quoteData.lineItems.forEach((item, index) => {
      if (!item.productId) {
        throw new PrintavoValidationError(
          `Product ID is required for line item ${index}`,
          { field: `lineItems[${index}].productId` },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (!validateQuantity(item.quantity)) {
        throw new PrintavoValidationError(`Invalid quantity for line item ${index}`);
      }
      if (!item.size) {
        throw new PrintavoValidationError(
          `Size is required for line item ${index}`,
          { field: `lineItems[${index}].size` },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (!item.color) {
        throw new PrintavoValidationError(
          `Color is required for line item ${index}`,
          { field: `lineItems[${index}].color` },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (item.price && !validatePrice(item.price)) {
        throw new PrintavoValidationError(
          `Invalid price for line item ${index}`,
          { field: `lineItems[${index}].price` },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
    });

    // Validate addresses if provided
    if (quoteData.shippingAddress) {
      if (!quoteData.shippingAddress.customerName) {
        throw new PrintavoValidationError(
          'Customer name is required for shipping address',
          { field: 'shippingAddress.customerName' },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (!quoteData.shippingAddress.address1) {
        throw new PrintavoValidationError(
          'Address line 1 is required for shipping address',
          { field: 'shippingAddress.address1' },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (!quoteData.shippingAddress.city) {
        throw new PrintavoValidationError(
          'City is required for shipping address',
          { field: 'shippingAddress.city' },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (!quoteData.shippingAddress.stateIso) {
        throw new PrintavoValidationError(
          'State is required for shipping address',
          { field: 'shippingAddress.stateIso' },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (!quoteData.shippingAddress.zipCode) {
        throw new PrintavoValidationError(
          'Zip code is required for shipping address',
          { field: 'shippingAddress.zipCode' },
          { code: ERROR_CODES.VALIDATION.REQUIRED_FIELD }
        );
      }
      if (quoteData.shippingAddress.zipCode && !validateZipCode(quoteData.shippingAddress.zipCode)) {
        throw new PrintavoValidationError(
          'Invalid zip code format for shipping address',
          { field: 'shippingAddress.zipCode' },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
    }

    // Validate due date if provided
    if (quoteData.dueDate && !isValidDate(quoteData.dueDate)) {
      throw new PrintavoValidationError(
        'Invalid due date format',
        { field: 'dueDate' },
        { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
      );
    }

    // Validate status ID if provided
    if (quoteData.statusId && !validateStatusId(quoteData.statusId)) {
      throw new PrintavoValidationError(
        'Invalid status ID',
        { field: 'statusId' },
        { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
      );
    }

    log(LOG_LEVELS.DEBUG, SERVICE_NAME, {
      action: 'validateQuoteInput',
      status: 'success'
    });
  } catch (error) {
    log(LOG_LEVELS.ERROR, SERVICE_NAME, {
      action: 'validateQuoteInput',
      status: 'failed',
      error: error.message,
      stack: error.stack
    });
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoValidationError(
      'Invalid quote data',
      error.errors || [{ message: error.message }],
      { 
        code: ERROR_CODES.VALIDATION.INVALID_INPUT,
        originalError: error.message 
      }
    );
  }
}

/**
 * Validates search criteria
 * @param {Object} criteria - The search criteria to validate
 * @throws {PrintavoValidationError} If validation fails
 */
function validateSearchCriteria(criteria) {
  try {
    log(LOG_LEVELS.DEBUG, 'Validating search criteria');
    const validatedData = searchCriteriaSchema.parse(criteria);

    // Additional custom validations
    if (validatedData.statusIds?.some(id => !validateStatusId(id))) {
      throw new PrintavoValidationError(
        'Invalid status ID format',
        { field: 'statusIds' },
        { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
      );
    }

    if (validatedData.dateRange) {
      if (!isValidDate(validatedData.dateRange.start)) {
        throw new PrintavoValidationError(
          'Invalid start date',
          { field: 'dateRange.start' },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
      if (!isValidDate(validatedData.dateRange.end)) {
        throw new PrintavoValidationError(
          'Invalid end date',
          { field: 'dateRange.end' },
          { code: ERROR_CODES.VALIDATION.INVALID_FORMAT }
        );
      }
    }

    log(LOG_LEVELS.DEBUG, SERVICE_NAME, {
      action: 'validateSearchCriteria',
      status: 'success'
    });
  } catch (error) {
    log(LOG_LEVELS.ERROR, SERVICE_NAME, {
      action: 'validateSearchCriteria',
      status: 'failed',
      error: error.message,
      stack: error.stack
    });
    if (error instanceof PrintavoValidationError) {
      throw error;
    }
    throw new PrintavoValidationError(
      'Invalid search criteria',
      error.errors || [{ message: error.message }],
      { 
        code: ERROR_CODES.VALIDATION.INVALID_INPUT,
        originalError: error.message 
      }
    );
  }
}

module.exports = {
  validateZipCode,
  validatePrice,
  validateQuantity,
  validateStatusId,
  validateWithRegex,
  isValidDate,
  validateInvoiceInput,
  validateQuoteInput,
  validateSearchCriteria
};

================
File: client/src/App.tsx
================
import { useState } from 'react'
import { useQuery, useMutation } from '@apollo/client'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'
import { Badge } from '@/components/ui/badge'
import { GET_ORDERS, CREATE_ORDER, DELETE_ORDER } from '@/graphql/queries'
import { ApolloTest } from '@/components/ApolloTest'
import ChatWidget from '@/components/ChatWidget'
// Temporarily remove ScrollArea until we can install it
// import { ScrollArea } from '../components/ui/scroll-area'

interface OrderNode {
  id: string
  createdAt: string
  status: string
  customerDueAt: string
  tags: string[]
  lineItemGroups: {
    edges: Array<{
      node: {
        id: string
        name: string
        lineItems: {
          edges: Array<{
            node: {
              id: string
              name: string
              sku: string
              quantity: number
              price: number
            }
          }>
        }
      }
    }>
  }
}

interface OrdersData {
  orders: {
    edges: Array<{
      node: OrderNode
    }>
    pageInfo: {
      hasNextPage: boolean
      endCursor: string
    }
  }
}

function App() {
  const [error, setError] = useState<string | null>(null)

  const { loading, data, refetch } = useQuery<OrdersData>(GET_ORDERS, {
    variables: { first: 10 },
    onError: (error) => setError(error.message)
  })

  const [createOrder] = useMutation(CREATE_ORDER, {
    onCompleted: () => refetch(),
    onError: (error) => setError(error.message)
  })

  const [deleteOrder] = useMutation(DELETE_ORDER, {
    onCompleted: () => refetch(),
    onError: (error) => setError(error.message)
  })

  const handleCreateOrder = async () => {
    try {
      await createOrder({
        variables: {
          input: {
            status: 'pending',
            customerDueAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // Due in 7 days
            tags: ['auto-created']
          }
        }
      })
    } catch (err) {
      // Error is handled by onError callback
    }
  }

  const handleDeleteOrder = async (id: string) => {
    try {
      await deleteOrder({
        variables: { id }
      })
    } catch (err) {
      // Error is handled by onError callback
    }
  }

  if (loading) {
    return <div className="flex items-center justify-center min-h-screen">Loading...</div>
  }

  if (error) {
    return (
      <Alert variant="destructive" className="max-w-2xl mx-auto mt-8">
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    )
  }

  const orders = data?.orders.edges.map(edge => edge.node) || []

  return (
    <div className="min-h-screen bg-gray-100">
      {/* Header */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8 flex justify-between items-center">
          <h1 className="text-3xl font-bold text-gray-900">SanMar Auto Order</h1>
          <Button onClick={handleCreateOrder}>Create New Order</Button>
        </div>
      </header>

      {/* Connection Test */}
      <div className="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
        <ApolloTest />
      </div>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
        <div className="overflow-auto h-[calc(100vh-200px)]">
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
            {orders.map((order) => (
              <Card key={order.id} className="hover:shadow-lg transition-shadow">
                <CardHeader>
                  <div className="flex justify-between items-start">
                    <div>
                      <CardTitle>Order #{order.id}</CardTitle>
                      <CardDescription>
                        Created: {new Date(order.createdAt).toLocaleDateString()}
                        <br />
                        Due: {new Date(order.customerDueAt).toLocaleDateString()}
                      </CardDescription>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="text-red-600 hover:text-red-800"
                      onClick={() => handleDeleteOrder(order.id)}
                    >
                      Delete
                    </Button>
                  </div>
                </CardHeader>
                <CardContent>
                  <div className="space-y-2">
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-gray-500">Status</span>
                      <Badge variant={order.status === 'completed' ? 'default' : 'secondary'}>
                        {order.status}
                      </Badge>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-gray-500">Items</span>
                      <span>
                        {order.lineItemGroups.edges.reduce(
                          (total, group) => total + group.node.lineItems.edges.length,
                          0
                        )}
                      </span>
                    </div>
                    {order.tags.length > 0 && (
                      <div className="flex flex-wrap gap-1 mt-2">
                        {order.tags.map(tag => (
                          <Badge key={tag} variant="outline">{tag}</Badge>
                        ))}
                      </div>
                    )}
                    <Button variant="outline" className="w-full mt-4">
                      View Details
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        </div>
      </main>

      {/* Chat Widget */}
      <ChatWidget />
    </div>
  )
}

export default App

================
File: client/src/components/ApolloTest.tsx
================
import { useQuery, gql } from '@apollo/client'
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'

const TEST_QUERY = gql`
  query TestConnection {
    account {
      id
      companyName
      companyEmail
    }
  }
`

interface TestData {
  account: {
    id: string
    companyName: string
    companyEmail: string
  }
}

export function ApolloTest() {
  const { loading, error, data } = useQuery<TestData>(TEST_QUERY)

  if (loading) {
    return <div>Testing connection...</div>
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertTitle>Connection Error</AlertTitle>
        <AlertDescription>
          {error.message}
          <br />
          <small className="block mt-2 text-xs">
            Please check your environment variables and API credentials.
          </small>
        </AlertDescription>
      </Alert>
    )
  }

  return (
    <Alert variant="default">
      <AlertTitle>Connected Successfully</AlertTitle>
      <AlertDescription>
        Connected to: {data?.account.companyName}
        <br />
        Account Email: {data?.account.companyEmail}
      </AlertDescription>
    </Alert>
  )
}

================
File: client/src/components/ChatWidget.tsx
================
import React, { useState, useRef, FormEvent } from 'react'

// Sample interface for chat messages
interface Message {
  role: 'user' | 'assistant'
  content: string
}

const ChatWidget: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false)
  const [messages, setMessages] = useState<Message[]>([])
  const [userInput, setUserInput] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const fileInputRef = useRef<HTMLInputElement | null>(null)

  // Toggles the chat widget open/closed
  const toggleChat = () => setIsOpen(!isOpen)

  // Sends a text message to the AI assistant
  const sendMessage = async (message: string) => {
    if (!message.trim()) return

    // Append user message to local chat
    setMessages(prev => [...prev, { role: 'user', content: message }])
    setUserInput('')
    setIsLoading(true)

    try {
      // Send message and conversation history to AI assistant
      const response = await fetch('/api/ai-assistant', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          userMessage: message,
          // Send last 10 messages for context
          conversationHistory: messages.slice(-10)
        })
      })
      
      if (!response.ok) {
        throw new Error('Failed to get response from AI assistant')
      }
      
      const data = await response.json()

      // Append assistant reply
      setMessages(prev => [...prev, { role: 'assistant', content: data.reply }])

      // If user triggered "create a quote for me (printavo)", handle required steps here
      // This is just an example of detecting that special command
      if (message.toLowerCase().includes('create a quote for me (printavo)')) {
        // Prompt the user for further info if needed
        setMessages(prev => [
          ...prev,
          {
            role: 'assistant',
            content:
              'Sure! Could you provide the customer contact email, product details, and any specific due date?'
          }
        ])
      }
    } catch (error: any) {
      setMessages(prev => [...prev, { 
        role: 'assistant', 
        content: 'Error: ' + (error.message || 'Failed to get response')
      }])
    } finally {
      setIsLoading(false)
    }
  }

  // Uploads file to backend for OCR processing and data parsing
  const handleFileChange = async () => {
    if (!fileInputRef.current?.files?.length) return
    setIsLoading(true)

    const formData = new FormData()
    formData.append('file', fileInputRef.current.files[0])

    try {
      // Send file to your backend, which should handle OCR
      const response = await fetch('/api/parse-document', {
        method: 'POST',
        body: formData
      })
      if (!response.ok) {
        throw new Error('Unable to parse document.')
      }
      const data = await response.json()

      // Show the AI assistant's interpretation in the chat
      setMessages(prev => [
        ...prev,
        {
          role: 'assistant',
          content: `File processed! Here's a summary from OCR:\n${data.rawText}`
        }
      ])
      // If data extraction includes some parsed info, you could also
      // automatically feed it into the conversation or store for later usage
    } catch (error: any) {
      setMessages(prev => [...prev, { role: 'assistant', content: 'Error: ' + error.message }])
    } finally {
      setIsLoading(false)
    }
  }

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()
    await sendMessage(userInput)
  }

  return (
    <>
      {/* Floating chat icon/button */}
      <div
        style={{
          position: 'fixed',
          bottom: '2rem',
          right: '2rem',
          zIndex: 1000
        }}
      >
        {!isOpen && (
          <button
            onClick={toggleChat}
            className="rounded-full bg-blue-600 text-white p-4 shadow-md hover:bg-blue-700 transition-colors"
          >
            Chat
          </button>
        )}
      </div>

      {/* Chat interface overlay */}
      {isOpen && (
        <div
          style={{
            position: 'fixed',
            bottom: '2rem',
            right: '2rem',
            width: '350px',
            height: '500px',
            backgroundColor: '#fff',
            border: '1px solid #ccc',
            borderRadius: '0.5rem',
            display: 'flex',
            flexDirection: 'column',
            zIndex: 1100
          }}
        >
          {/* Header */}
          <div
            style={{
              backgroundColor: '#f5f5f5',
              padding: '0.5rem',
              borderBottom: '1px solid #ccc',
              display: 'flex',
              justifyContent: 'space-between'
            }}
          >
            <h2 style={{ margin: 0 }}>Chat with AI</h2>
            <button onClick={toggleChat} style={{ background: 'none', border: 'none' }}>
              
            </button>
          </div>

          {/* Messages list */}
          <div
            style={{
              flex: 1,
              padding: '0.5rem',
              overflowY: 'auto'
            }}
          >
            {messages.map((m, idx) => (
              <div key={idx} style={{ marginBottom: '1rem' }}>
                <strong>{m.role === 'user' ? 'You' : 'AI'}:</strong>
                <div>{m.content}</div>
              </div>
            ))}
            {isLoading && <div>Thinking...</div>}
          </div>

          {/* File upload */}
          <div style={{ padding: '0.5rem', borderTop: '1px solid #ccc' }}>
            <label
              style={{
                display: 'inline-block',
                marginBottom: '0.5rem',
                cursor: 'pointer',
                color: 'blue',
                textDecoration: 'underline'
              }}
            >
              Upload file for OCR
              <input
                type="file"
                accept=".pdf,image/*"
                style={{ display: 'none' }}
                ref={fileInputRef}
                onChange={handleFileChange}
              />
            </label>
          </div>

          {/* Message input */}
          <form onSubmit={handleSubmit} style={{ display: 'flex', borderTop: '1px solid #ccc' }}>
            <input
              type="text"
              placeholder="Type your message..."
              value={userInput}
              onChange={e => setUserInput(e.target.value)}
              style={{
                flex: 1,
                padding: '0.5rem',
                border: 'none',
                outline: 'none'
              }}
            />
            <button
              type="submit"
              style={{
                backgroundColor: '#3182CE',
                color: '#fff',
                border: 'none',
                padding: '0.5rem 1rem',
                cursor: 'pointer'
              }}
              disabled={isLoading}
            >
              Send
            </button>
          </form>
        </div>
      )}
    </>
  )
}

export default ChatWidget

================
File: client/src/components/ui/accordion.tsx
================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className={cn(
      "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
      className
    )}
    {...props}
  >
    <div className="pb-4 pt-0">{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

================
File: client/src/components/ui/alert-dialog.tsx
================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = ({
  className,
  children,
  ...props
}: AlertDialogPrimitive.AlertDialogPortalProps) => (
  <AlertDialogPrimitive.Portal className={cn(className)} {...props}>
    <div className="fixed inset-0 z-50 flex items-end justify-center sm:items-center">
      {children}
    </div>
  </AlertDialogPrimitive.Portal>
)
AlertDialogPortal.displayName = AlertDialogPrimitive.Portal.displayName

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, children, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm transition-opacity animate-in fade-in",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed z-50 grid w-full max-w-lg scale-100 gap-4 border bg-background p-6 opacity-100 shadow-lg animate-in fade-in-90 slide-in-from-bottom-10 sm:rounded-lg sm:zoom-in-90 sm:slide-in-from-bottom-0",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: client/src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg]:absolute [&>svg]:text-foreground [&>svg]:left-4 [&>svg]:top-4 [&>svg+div]:translate-y-[-3px] [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "text-destructive border-destructive/50 dark:border-destructive [&>svg]:text-destructive text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

================
File: client/src/components/ui/aspect-ratio.tsx
================
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

================
File: client/src/components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: client/src/components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center border rounded-full px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "bg-primary hover:bg-primary/80 border-transparent text-primary-foreground",
        secondary:
          "bg-secondary hover:bg-secondary/80 border-transparent text-secondary-foreground",
        destructive:
          "bg-destructive hover:bg-destructive/80 border-transparent text-destructive-foreground",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: client/src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: client/src/components/ui/calendar.tsx
================
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "text-center text-sm p-0 relative [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "text-muted-foreground opacity-50",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

================
File: client/src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(" flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: client/src/env.d.ts
================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly PRINTAVO_API_URL: string
  readonly PRINTAVO_ACCESS_TOKEN: string
  readonly PRINTAVO_EMAIL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

================
File: client/src/graphql/queries.ts
================
import { gql } from '@apollo/client'

export const GET_ORDERS = gql`
  query GetOrders($first: Int, $after: String) {
    orders(first: $first, after: $after) {
      edges {
        node {
          id
          createdAt
          status
          customerDueAt
          tags
          lineItemGroups {
            edges {
              node {
                id
                name
                lineItems {
                  edges {
                    node {
                      id
                      name
                      sku
                      quantity
                      price
                    }
                  }
                }
              }
            }
          }
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
`

export const GET_ORDER = gql`
  query GetOrder($id: ID!) {
    order(id: $id) {
      id
      createdAt
      status
      customerDueAt
      tags
      lineItemGroups {
        edges {
          node {
            id
            name
            lineItems {
              edges {
                node {
                  id
                  name
                  sku
                  quantity
                  price
                }
              }
            }
          }
        }
      }
    }
  }
`

export const CREATE_ORDER = gql`
  mutation CreateOrder($input: OrderCreateInput!) {
    orderCreate(input: $input) {
      order {
        id
        createdAt
        status
        customerDueAt
        tags
      }
      errors {
        field
        message
      }
    }
  }
`

export const UPDATE_ORDER = gql`
  mutation UpdateOrder($id: ID!, $input: OrderUpdateInput!) {
    orderUpdate(id: $id, input: $input) {
      order {
        id
        createdAt
        status
        customerDueAt
        tags
      }
      errors {
        field
        message
      }
    }
  }
`

export const DELETE_ORDER = gql`
  mutation DeleteOrder($id: ID!) {
    orderDelete(id: $id) {
      success
      errors {
        field
        message
      }
    }
  }
`

================
File: client/src/lib/apollo.ts
================
import { ApolloClient, InMemoryCache, createHttpLink, from } from '@apollo/client'
import { onError } from '@apollo/client/link/error'

// Validate environment variables
const validateEnvVariables = () => {
  const required = {
    'PRINTAVO_API_URL': import.meta.env.PRINTAVO_API_URL,
    'PRINTAVO_ACCESS_TOKEN': import.meta.env.PRINTAVO_ACCESS_TOKEN,
    'PRINTAVO_EMAIL': import.meta.env.PRINTAVO_EMAIL,
  }

  const missing = Object.entries(required)
    .filter(([_, value]) => !value)
    .map(([key]) => key)

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`)
  }
}

// Validate environment variables immediately
validateEnvVariables()

// Error handling link
const errorLink = onError(({ graphQLErrors, networkError }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(
        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`
      )
    })
  }
  if (networkError) {
    console.error(`[Network error]: ${networkError}`)
  }
})

const httpLink = createHttpLink({
  uri: import.meta.env.PRINTAVO_API_URL,
  headers: {
    'X-Access-Token': import.meta.env.PRINTAVO_ACCESS_TOKEN,
    'X-User-Email': import.meta.env.PRINTAVO_EMAIL,
  }
})

export const apolloClient = new ApolloClient({
  link: from([errorLink, httpLink]),
  cache: new InMemoryCache({
    typePolicies: {
      Query: {
        fields: {
          orders: {
            // Proper pagination merge function
            keyArgs: false,
            merge(existing = { edges: [] }, incoming) {
              return {
                ...incoming,
                edges: [...existing.edges, ...incoming.edges],
              }
            },
          },
        },
      },
    },
  }),
  defaultOptions: {
    watchQuery: {
      fetchPolicy: 'network-only',
    },
    query: {
      fetchPolicy: 'network-only',
    },
  },
})

================
File: client/src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: client/src/main.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import { ApolloProvider } from '@apollo/client'
import { apolloClient } from '@/lib/apollo'
import App from '@/App'
import '@/index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ApolloProvider client={apolloClient}>
      <App />
    </ApolloProvider>
  </React.StrictMode>,
)

================
File: client/src/services/api.ts
================
const API_BASE_URL = 'http://localhost:3000/api'

export interface Order {
  id: string
  createdAt: string
  status: 'pending' | 'processing' | 'completed' | 'failed'
  items: Array<{
    id: string
    name: string
    quantity: number
    sku: string
  }>
}

export const api = {
  async getOrders(): Promise<Order[]> {
    const response = await fetch(`${API_BASE_URL}/orders`)
    if (!response.ok) {
      throw new Error('Failed to fetch orders')
    }
    return response.json()
  },

  async createOrder(orderData: Omit<Order, 'id' | 'createdAt'>): Promise<Order> {
    const response = await fetch(`${API_BASE_URL}/orders`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(orderData),
    })
    if (!response.ok) {
      throw new Error('Failed to create order')
    }
    return response.json()
  },

  async updateOrder(id: string, orderData: Partial<Order>): Promise<Order> {
    const response = await fetch(`${API_BASE_URL}/orders/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(orderData),
    })
    if (!response.ok) {
      throw new Error('Failed to update order')
    }
    return response.json()
  },

  async deleteOrder(id: string): Promise<void> {
    const response = await fetch(`${API_BASE_URL}/orders/${id}`, {
      method: 'DELETE',
    })
    if (!response.ok) {
      throw new Error('Failed to delete order')
    }
  },
}

================
File: client/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: docs/architecture.md
================
# Architecture Overview

## High-Level Overview
The SanMar Auto Order Integration is built with a modular architecture consisting of several key components:

1. **API Layer**
   - Express.js routes
   - Middleware for authentication and validation

2. **Service Layer**
   - OCR processing service
   - Printavo integration service
   - Line item parsing service

3. **Utility Layer**
   - File handling utilities
   - PDF conversion utilities
   - OCR processing utilities

## Data Flow

1. **Input Processing**
   ```
   PDF Invoice  PDF to Image Conversion  OCR Text Extraction  Data Parsing
   ```

2. **Data Validation**
   ```
   Parsed Data  Schema Validation  Business Rule Validation  Error Checking
   ```

3. **Printavo Integration**
   ```
   Validated Data  GraphQL Query/Mutation  Response Validation  Result
   ```

4. **Error Handling**
   ```
   Error Detection  Error Classification  Retry Logic  Error Reporting
   ```

## Key Technologies

### Core Technologies
- **Node.js**: Runtime environment
- **Express.js**: Web framework
- **GraphQL**: API integration with Printavo
- **Tesseract.js**: OCR processing

### Libraries and Tools
- **graphql-request**: GraphQL client
- **pdf2img**: PDF processing
- **zod**: Schema validation
- **dotenv**: Environment configuration
- **debug**: Logging and debugging

### Development Tools
- **nodemon**: Development server
- **ESLint**: Code linting
- **Git**: Version control

## Component Diagram (Text Description)

```
[Client]
     HTTP
[Express Server]
     File Upload
[OCR Processing]
    | PDF2Image
    | Tesseract
     Text Data
[Data Parser]
     Structured Data
[Validation Layer]
    | Zod Schemas
    | Business Rules
     Validated Data
[Printavo Service]
    | GraphQL Client
    | Rate Limiting
    | Error Handling
     API Requests
[Printavo API]
```

## Security Considerations
- Environment-based configuration
- Sensitive data masking in logs
- API token management
- Rate limiting protection
- Input validation and sanitization

## Error Handling Strategy
- Custom error classes for different scenarios
- Automatic retry for transient failures
- Detailed error logging with request tracking
- Graceful degradation under load

================
File: docs/data_models.md
================
# Data Models

## Core Data Models

### 1. Invoice Model
**Purpose**: Represents a complete order in the Printavo system
**Fields**:
```javascript
{
  id: "Unique identifier for the invoice",
  visualId: "Human-readable invoice number",
  status: {
    id: "Status identifier (e.g., 'new', 'in_production')",
    name: "Human-readable status name"
  },
  contact: {
    id: "Unique identifier for the contact",
    fullName: "Contact's full name",
    email: "Contact's email address (optional)"
  },
  lineItemGroups: {
    nodes: [/* Array of line item groups */]
  },
  shippingAddress: {
    address1: "Street address",
    address2: "Additional address info (optional)",
    city: "City name",
    stateIso: "Two-letter state code",
    zipCode: "Postal code",
    country: "Country code (default: US)",
    phone: "Phone number (optional)",
    email: "Email address (optional)"
  }
}
```

### 2. Line Item Model
**Purpose**: Represents a single product item in an order
**Fields**:
```javascript
{
  id: "Unique identifier for the line item",
  product: {
    id: "Product identifier",
    itemNumber: "Product SKU or number",
    description: "Product description"
  },
  items: "Quantity ordered",
  price: "Price per item",
  size: "Product size",
  color: "Product color"
}
```

### 3. Contact Model
**Purpose**: Represents a customer or contact in the system
**Fields**:
```javascript
{
  id: "Unique identifier for the contact",
  fullName: "Contact's full name",
  email: "Contact's email address",
  phone: "Contact's phone number (optional)",
  company: "Company name (optional)"
}
```

## Validation Constants

### Address Validation
```javascript
const VALIDATION_CONSTANTS = {
  VALID_STATE_CODES: [
    'AL', 'AK', 'AZ', /* ... all US state codes ... */
  ],
  VALID_COUNTRIES: ['US', 'USA', 'CA', 'CAN'],
  ZIP_CODE_PATTERNS: {
    US: /^\d{5}(-\d{4})?$/,
    CA: /^[A-Za-z]\d[A-Za-z][ -]?\d[A-Za-z]\d$/
  }
};
```

### Product Validation
```javascript
const VALIDATION_CONSTANTS = {
  MAX_LINE_ITEMS: 100,
  MIN_QUANTITY: 1,
  MAX_QUANTITY: 10000,
  MAX_PRICE: 1000000,
  PRODUCT_ID_PATTERN: /^[A-Za-z0-9-_]+$/,
  COLOR_PATTERN: /^[A-Za-z0-9\s-]+$/,
  SIZE_PATTERN: /^[A-Za-z0-9XSMLxsml\s-]+$/
};
```

## GraphQL Types

### Query Types
```graphql
type Query {
  invoice(id: ID!): Invoice
  invoices(first: Int!, after: String): InvoiceConnection
  contacts(filter: ContactFilter, first: Int): ContactConnection
  account: Account
}
```

### Mutation Types
```graphql
type Mutation {
  invoiceCreate(input: InvoiceCreateInput!): InvoiceCreatePayload
}
```

### Connection Types
```graphql
type InvoiceConnection {
  nodes: [Invoice]
  pageInfo: PageInfo
  totalCount: Int
}

type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}
```

## Error Types

### API Errors
```javascript
class PrintavoAPIError {
  name: "Name of the error",
  message: "Error message",
  code: "Error code (e.g., 'VALIDATION_ERROR')",
  details: {
    // Additional error details
  }
}
```

### Validation Errors
```javascript
class PrintavoValidationError {
  name: "PrintavoValidationError",
  message: "Validation error message",
  errors: [
    {
      field: "Field that failed validation",
      message: "Specific validation error message"
    }
  ]
}
```

## Data Flow Types

### OCR Result
```javascript
type OCRResult = {
  text: string,          // Raw extracted text
  confidence: number,    // OCR confidence score
  pageNumber: number,    // Page number in PDF
  bounds: {             // Text location in image
    left: number,
    top: number,
    width: number,
    height: number
  }
}
```

### Parsed Invoice Data
```javascript
type ParsedInvoiceData = {
  orderNumber: string,
  items: Array<{
    productId: string,
    quantity: number,
    price: number,
    size: string,
    color: string
  }>,
  customer: {
    name: string,
    email: string,
    address: {
      // Address fields
    }
  }
}

================
File: docs/how_it_works.md
================
# How It Works

## Core Functionality

### 1. OCR Invoice Processing

The OCR processing pipeline consists of several steps:

1. **PDF Handling**
   ```javascript
   // Convert PDF pages to images
   async function convertPDFToImages(pdfPath) {
     // Returns array of image paths for each page
   }
   ```

2. **Text Extraction**
   - Uses Tesseract.js for OCR processing
   - Processes each page image separately
   - Combines results from all pages

3. **Data Parsing**
   - Extracts structured data from OCR text
   - Identifies line items, quantities, and prices
   - Maps extracted data to Printavo format

### 2. Printavo Integration

The Printavo service handles all interactions with the Printavo GraphQL API:

1. **Client Initialization**
   ```javascript
   // Initialize GraphQL client with authentication
   const client = new GraphQLClient(process.env.PRINTAVO_API_URL, {
     headers: {
       'Content-Type': 'application/json',
       'email': process.env.PRINTAVO_EMAIL,
       'token': process.env.PRINTAVO_ACCESS_TOKEN
     }
   });
   ```

2. **GraphQL Operations**
   - Query operations for fetching data
   - Mutation operations for creating/updating orders
   - Pagination handling for large result sets

3. **Rate Limiting**
   - Implements retry logic with exponential backoff
   - Respects Printavo's rate limits (10 requests per 5 seconds)
   - Queues requests when approaching limits

### 3. Data Validation

Comprehensive validation is implemented using Zod schemas:

1. **Schema Definitions**
   ```javascript
   const addressSchema = z.object({
     address1: z.string().min(1).max(255),
     city: z.string().min(1).max(255),
     stateIso: z.string().length(2),
     // ... more fields
   });

   const lineItemSchema = z.object({
     productId: z.string(),
     quantity: z.number().int().positive(),
     // ... more fields
   });
   ```

2. **Validation Process**
   - Schema validation for data structure
   - Business rule validation for data values
   - Custom validation for specific fields

3. **Error Handling**
   - Detailed error messages for validation failures
   - Error aggregation for multiple issues
   - Error classification by type

### 4. Error Handling

The error handling system uses custom error classes:

1. **Error Classes**
   ```javascript
   class PrintavoAPIError extends Error {
     constructor(message, code, details = {}) {
       super(message);
       this.name = 'PrintavoAPIError';
       this.code = code;
       this.details = details;
     }
   }
   ```

2. **Error Types**
   - Validation errors
   - Authentication errors
   - API errors
   - Network errors

3. **Retry Logic**
   - Automatic retries for transient failures
   - Configurable retry attempts and delays
   - Different strategies based on error type

### 5. Logging System

Comprehensive logging is implemented throughout:

1. **Log Structure**
   ```javascript
   const log = (level, message, data = {}) => {
     const logEntry = {
       timestamp: new Date().toISOString(),
       level,
       message,
       requestId: randomUUID(),
       ...data
     };
     // ... logging logic
   };
   ```

2. **Log Levels**
   - ERROR: Critical issues
   - WARN: Important but non-critical issues
   - INFO: General operational information
   - DEBUG: Detailed debugging information

3. **Security Features**
   - Sensitive data masking
   - Request ID tracking
   - Error stack traces in development

## Important Algorithms

### 1. Rate Limiting Algorithm
```javascript
async function executeGraphQL(query, variables, options = { maxRetries: 3, retryDelay: 1000 }) {
  for (let attempt = 1; attempt <= options.maxRetries; attempt++) {
    try {
      return await client.request(query, variables);
    } catch (error) {
      if (error.response?.status === 429) {
        const retryDelay = options.retryDelay * attempt;
        await new Promise(resolve => setTimeout(resolve, retryDelay));
        continue;
      }
      throw error;
    }
  }
}
```

### 2. Validation Algorithm
```javascript
function validateInvoiceInput(invoiceData) {
  // Schema validation
  const validationResult = invoiceSchema.safeParse(invoiceData);
  if (!validationResult.success) {
    throw new PrintavoValidationError('Validation failed', validationResult.error);
  }

  // Business rule validation
  validateBusinessRules(validationResult.data);
}
```

## Data Structures

### 1. Invoice Data Structure
```javascript
{
  id: string,
  visualId: string,
  status: {
    id: string,
    name: string
  },
  contact: {
    id: string,
    fullName: string,
    email: string
  },
  lineItemGroups: {
    nodes: [{
      id: string,
      lineItems: {
        nodes: [{
          id: string,
          product: {
            id: string,
            itemNumber: string,
            description: string
          },
          items: number,
          price: number,
          size: string,
          color: string
        }]
      }
    }]
  },
  shippingAddress: {
    address1: string,
    city: string,
    stateIso: string,
    zipCode: string,
    // ... more fields
  }
}

================
File: docs/Printavo/auth.md
================
# Authentication

Requests to Printavo API v2.0 are made to the following endpoint:

`www.printavo.com/api/v2`

Authentication Headers:
Use code with caution.
Markdown
const headers = {
'Content-Type': 'application/json',
'email': 'sales@kingclothing.com',
'token': 'uyZXl2kWJNSXwR_MXMuNWQ'
};

To use this API you would need to include the following headers to any request you make.
`Content-Type` is `application/json` and your `email` and `token`
Rate Limiting: Maximum of 10 requests for every 5 seconds per user email or IP address.

================
File: docs/Printavo/Connections.md
================
# Connections

Connection types are used to implement pagination.

Examples of Connections:
 - `ApprovalConnection`
 - `ApprovalRequestConnection`
 - `CategoryConnection`
 - `ContactConnection`
 - `CustomerConnection`
 - `DeliveryMethodConnection`
 - `EmailTemplateConnection`
 - `ExpenseConnection`
 - `FeeConnection`
 - `ImprintConnection`
 - `InquiryConnection`
 - `InvoiceConnection`
 - `LineItemConnection`
 - `LineItemGroupConnection`
 - `MerchOrderConnection`
 - `MerchStoreConnection`
 - `MessageAttachmentConnection`
 - `MessageUnionConnection`
 - `MockupConnection`
 - `OrderUnionConnection`
 - `PaymentDisputeConnection`
 - `PaymentRequestConnection`
 - `PaymentTermConnection`
 - `PoLineItemConnection`
 - `PresetTaskConnection`
 - `PresetTaskGroupConnection`
 - `PricingMatrixCellConnection`
 - `PricingMatrixConnection`
 - `ProductionFileConnection`
 - `QuoteConnection`
 - `StatusConnection`
 - `TaskConnection`
 - `ThreadSummaryConnection`
 - `TransactionUnionConnection`
 - `TypeOfWorkConnection`
 - `UserConnection`

================
File: docs/Printavo/Directives.md
================
# Directives

Directives provide a way to describe alternate runtime execution and type validation behavior.

Examples of directives:
- `@deprecated`
- `@include`
- `@skip`
- `@oneOf`

For more information, see [the GraphQL spec](https://graphql.github.io/graphql-spec/draft/#sec-Language.Directives).

================
File: docs/Printavo/Enums.md
================
# Enums

Enums represent a set of possible values for a field.

Examples of enums:
- `TaskableType`
- `LineItemSize`
- `LineItemStatus`
- `MerchOrderStatus`
- `MerchStoreStatus`
- `MessageDeliveryStatus`
- `OrderPaymentStatus`
- `OrderSortField`
- `PaymentDisputeStatusField`
- `PoGoodsStatus`
- `StatusType`
- `TaskSortField`
- `TransactionCategory`
- `TransactionSource`

For more information, see [the GraphQL spec](https://facebook.github.io/graphql/#sec-Enums).

================
File: docs/Printavo/graphql_concepts.md
================
# GraphQL Concepts

GraphQL is designed to limit excess in requests and responses, providing users with tools to tailor actions to their needs. The core concept is "ask for what you want and that's exactly what you'll get".

## Types and Fields

Data models are called "types", and information is stored in their "fields". A request defines the specific fields it wants to query or mutate.

## Collections and Pagination

A set of data objects is returned in a [connection](https://graphql-ruby.org/pagination/connection_concepts), and each individual object inside the connection object is called a "node".

The Printavo API paginates connections into pages of twenty-five nodes. Each connection reports its `totalNodes` value. GraphQL supports [slicing](https://graphql.org/learn/pagination/#slicing) to specify where in the list to begin and how many nodes to request.

Example:
```graphql
query {
  tasks {
    nodes(first: 5) {
      id
    }
  }
}
Use code with caution.
Markdown
Aliasing
GraphQL supports aliasing for queries, mutations, and fields to customize labels in returned data.

Example:

query {
  taskAlias: tasks {
    nodes {
      nameAlias: name
    }
  }
}
Use code with caution.
Graphql
Response:

{
  "data": {
    "taskAlias": {
      "nodes": [
        {
          "nameAlias": "Prepare the screens"
        },
        ...
      ]
    }
  }
}
Use code with caution.
Json
Conventions: The Use of !
! indicates two meanings:

Argument: A required argument.

query {
  task(id: ID!) {
	...
  }
}
Use code with caution.
Graphql
In the task query, an ID value is required.
2. Returned Field: A non-nullable value. For connections, it signifies that GraphQL will always return a connection even if that connection is empty.

Example:

fees (FeeConnection!)
Use code with caution.
Even if no fees are attached to an Invoice, a connection will always be returned.

Queries vs Mutations
Queries: Retrieve data.

Mutations: Modify data (analogous to HTTP verbs like POST, PATCH, DELETE).

Continued Reading
For more information check out GraphQL's official documentation

---

================
File: docs/Printavo/Interfaces.md
================
# Interfaces

Interfaces are "parent objects" from which other objects can inherit.

Examples of interfaces:
- `MailAddress`
- `Timestamps`
- `VisualIDed`
- `IDed`
- `Message`

For more information, see [the GraphQL spec](https://facebook.github.io/graphql/#sec-Interfaces).

================
File: docs/Printavo/Mutations.md
================
# Mutations

Mutations are used to modify data on the server

Example: Update a contact

```graphql
mutation {
  contactUpdate(
    id: 1
    input: { email: ["john.doe@example.com", "jane.doe@example.com"] }
  ) {
    id
    email
  }
}

Example: Update an invoice and its shipping address.

mutation {
  invoiceUpdate(
    id: 123
    input: {
      contact: { id: 456 }
      customerNote: "Extra charge for rush shipping"
      productionNote: "Rush job, make sure this goes out today!"
      customerDueAt: "2023-07-04"
      tags: ["#rush"]
      shippingAddress: {
        companyName: "ACME"
        customerName: "Wile E. Coyote"
        address1: "123 Main Street"
        address2: "Apt. 551"
        city: "Albuquerque"
        stateIso: "NM"
        zipCode: "87121"
      }
    }
  ) {
    id
    contact {
      id
      email
    }
    customerNote
    productionNote
    customerDueAt
    tags
    shippingAddress {
      companyName
      customerName
      address1
      address2
      city
      stateIso
      zipCode
    }
  }
}
Use code with caution.
Graphql
Mutations include, but aren't limited to:

approvalRequestApprove

approvalRequestCreate

approvalRequestRevoke

contactCreate

contactDelete

contactUpdate

customerCreate

customerDelete

customerUpdate

customAddressCreate

customAddressDelete

customAddressUpdates

deliveryMethodArchive

deliveryMethodCreate

deliveryMethodUpdate

emailMessageCreate

feeCreate

feeDelete

feeCreates

feeUpdates

imprintCreate

imprintDelete

imprintCreates

imprintMockupCreate

imprintUpdates

inquiryCreate

inquiryDelete

inquiryUpdate

invoiceDelete

invoiceDuplicate

invoiceUpdate

lineItemCreate

lineItemDelete

lineItemDeletes

lineItemMockupCreate

lineItemMockupCreates

lineItemGroupCreate

lineItemGroupDelete

lineItemGroupUpdates

lineItemUpdates

login

logout

mockupDelete

mockupDeletes

paymentRequestCreate

paymentRequestDelete

paymentTermArchive

paymentTermCreate

paymentTermUpdate

presetTaskCreate

presetTaskDelete

presetTaskGroupApply

presetTaskGroupCreate

presetTaskGroupDelete

presetTaskGroupUpdate

productionFileCreate

productionFileDelete

productionFileCreates

quoteCreate

quoteDelete

quoteDuplicate

quoteUpdate

statusUpdate

taskCreate

taskDelete

threadUpdate

transactionPaymentCreate

transactionPaymentDelete

transactionPaymentUpdate

================
File: docs/Printavo/objects.md
================
---

**File: 3_objects.md**
```markdown
# Objects

Objects represent the resources you can access and contain typed fields.

Examples of object types:
- `Account`
- `Address`
- `Approval`
- `ApprovalRequest`
- `Category`
- `Contact`
- `Customer`
- `DeliveryMethod`
- `EmailMessage`
- `EmailTemplate`
- `Expense`
- `Fee`
- `Imprint`
- `Inquiry`
- `Invoice`
- `LineItem`
- `LineItemGroup`
- `MerchAddress`
- `MerchOrder`
- `MerchStore`
- `Mockup`
- `Payment`
- `PaymentDispute`
- `PaymentRequest`
- `PaymentTerm`
- `Personalization`
- `PoLineItem`
- `PresetTask`
- `PresetTaskGroup`
- `PricingMatrix`
- `PricingMatrixCell`
- `ProductionFile`
- `PurchaseOrder`
- `Quote`
- `Refund`
- `Return`
- `Status`
- `Task`
- `TextMessage`
- `TransactionDetails`
- `TypeOfWork`
- `User`
- `Vendor`
- `Void`

================
File: docs/Printavo/operations.md
================
# Printavo GraphQL Operations Documentation

This document provides comprehensive documentation for key Printavo GraphQL operations including connection verification, invoice creation, and invoice searching.

## Table of Contents
- [Verify Connection](#verify-connection)
- [Create Invoice](#create-invoice)
- [Search Invoices](#search-invoices)

## Verify Connection

The `verifyConnection` operation allows you to test the connection to the Printavo API and validate your authentication credentials.

### Usage

```javascript
const printavoService = require('../services/printavoService');

try {
  const isConnected = await printavoService.account.verifyConnection();
  if (isConnected) {
    console.log('Successfully connected to Printavo API');
  }
} catch (error) {
  console.error('Connection verification failed:', error.message);
}
```

### Response

Returns a boolean indicating whether the connection was successful.

### Error Handling

- `PrintavoAuthenticationError`: Thrown when authentication credentials are invalid
- `PrintavoAPIError`: Thrown when the API request fails for other reasons

## Create Invoice

The `createInvoice` operation allows you to create a new invoice in Printavo with line items, contact information, and other details.

### Input Parameters

```typescript
interface InvoiceCreateInput {
  contactId: string;              // Required: ID of the contact
  dueDate?: string;              // Optional: Due date for the invoice
  lineItems: Array<{
    productId: string;           // Required: Product ID
    quantity: number;            // Required: Quantity
    size: string;               // Required: Size code
    color: string;              // Required: Color code
    price: number;              // Required: Unit price
    imprints?: Array<{         // Optional: Imprint specifications
      name: string;            // Required: Imprint name
      description?: string;    // Optional: Imprint description
      location: string;        // Required: Imprint location
      colors: Array<string>;   // Required: Array of colors
    }>;
  }>;
  shippingAddress?: {           // Optional: Shipping address
    companyName?: string;
    customerName?: string;
    address1: string;
    address2?: string;
    city: string;
    stateIso: string;
    zipCode: string;
    countryIso: string;
  };
  billingAddress?: {            // Optional: Billing address
    // Same structure as shippingAddress
  };
  customerNote?: string;        // Optional: Customer-facing note
  productionNote?: string;      // Optional: Production-specific note
  internalNote?: string;        // Optional: Internal note
  tags?: Array<string>;         // Optional: Array of tags
  statusId?: string;            // Optional: ID of the invoice status
  paymentTermsId?: string;      // Optional: ID of the payment terms
  deliveryMethodId?: string;    // Optional: ID of the delivery method
  depositRequired?: number;     // Optional: Required deposit amount
}
```

### Usage Example

```javascript
const printavoService = require('../services/printavoService');

const invoiceData = {
  contactId: "contact_123",
  lineItems: [{
    productId: "prod_456",
    quantity: 100,
    size: "L",
    color: "Navy",
    price: 15.99,
    imprints: [{
      name: "Front Logo",
      location: "Center Front",
      colors: ["White"]
    }]
  }],
  shippingAddress: {
    companyName: "Acme Corp",
    address1: "123 Main St",
    city: "Springfield",
    stateIso: "IL",
    zipCode: "62701",
    countryIso: "US"
  },
  customerNote: "Please deliver during business hours",
  tags: ["rush", "corporate"]
};

try {
  const newInvoice = await printavoService.invoices.createInvoice(invoiceData);
  console.log('Invoice created:', newInvoice.id);
} catch (error) {
  console.error('Failed to create invoice:', error.message);
}
```

### Response

Returns the created invoice object with all details including:
- Invoice ID and visual ID
- Contact information
- Line items and imprints
- Addresses
- Notes and tags
- Payment information
- Timestamps

### Error Handling

- `PrintavoValidationError`: Thrown when input data is invalid
- `PrintavoAPIError`: Thrown when the API request fails
- Specific error messages will be included in the `errors` array of the response

## Search Invoices

The `getRecentInvoices` operation allows you to search and retrieve invoices based on various criteria.

### Query Parameters

```typescript
interface InvoiceQueryOptions {
  first?: number;              // Optional: Number of invoices to fetch (max 25)
  after?: string;             // Optional: Cursor for pagination
  statusIds?: string[];       // Optional: Filter by status IDs
  inProductionAfter?: string; // Optional: Filter by production start date
  inProductionBefore?: string;// Optional: Filter by production end date
  paymentStatus?: string;     // Optional: Filter by payment status
  sortOn?: string;           // Optional: Field to sort on
  sortDescending?: boolean;   // Optional: Sort direction
  searchTerm?: string;       // Optional: Search term for filtering
  tags?: string[];          // Optional: Filter by tags
}
```

### Usage Example

```javascript
const printavoService = require('../services/printavoService');

const searchOptions = {
  first: 10,
  statusIds: ["status_789"],
  paymentStatus: "PAID",
  sortOn: "createdAt",
  sortDescending: true,
  tags: ["rush"]
};

try {
  const result = await printavoService.invoices.getRecentInvoices(searchOptions);
  console.log('Found invoices:', result.nodes);
  console.log('Pagination info:', result.pageInfo);
  console.log('Total count:', result.totalNodes);
} catch (error) {
  console.error('Failed to search invoices:', error.message);
}
```

### Response

Returns an object containing:
- `nodes`: Array of invoice objects
- `pageInfo`: Pagination information including:
  - `hasNextPage`: Boolean indicating if more results exist
  - `endCursor`: Cursor for fetching next page
- `totalNodes`: Total count of matching invoices

### Error Handling

- `PrintavoValidationError`: Thrown when query parameters are invalid
- `PrintavoAPIError`: Thrown when the API request fails
- Specific error messages will be included in the error object

### Pagination

To implement pagination:

```javascript
async function fetchAllInvoices(searchOptions) {
  let allInvoices = [];
  let hasMore = true;
  let cursor = null;

  while (hasMore) {
    const result = await printavoService.invoices.getRecentInvoices({
      ...searchOptions,
      first: 25,
      after: cursor
    });

    allInvoices = [...allInvoices, ...result.nodes];
    hasMore = result.pageInfo.hasNextPage;
    cursor = result.pageInfo.endCursor;
  }

  return allInvoices;
}

================
File: docs/Printavo/queries_gemini.md
================
**File: 11_queries.md**
```markdown
# Queries

Queries are used to retrieve data from the server.

Example: Fetch a customer
```graphql
query {
  contact(id: 12345) {
    id
    fullName
    email
  }
}

Example: Fetch Orders
query {
  orders(
    inProductionAfter: "2023-04-01T00:00:00Z"
    inProductionBefore: "2023-05-01T00:00:00Z"
    statusIds: ["4", "5"]
    first: 10
    sortOn: VISUAL_ID
  ) {
    nodes {
      ... on Quote {
        id
        visualId
        contact {
          id
          email
        }
      }
      ... on Invoice {
        id
        visualId
        owner {
          id
          email
        }
      }
    }
  }
}

Queries include, but aren't limited to:

account

contact

contacts

customer

customers

inquiries

inquiry

invoice

invoices

lineItem

lineItemGroup

lineItemGroupPricing

merchOrder

merchStore

merchStores

order

orders

paymentRequests

products

quotes

quote

statuses

status

tasks

task

threads

thread

transaction

transactions

transactionDetail

user

================
File: docs/Printavo/Scalars.md
================
# Scalars

Scalars are primitive values.

Examples of scalars:
- `Int`
- `String`
- `Float`
- `Boolean`
- `ID`
- `ISO8601Date`
- `ISO8601DateTime`

For more information, see [the GraphQL spec](https://facebook.github.io/graphql/#sec-Scalars).

================
File: docs/Printavo/unions.md
================
# Unions

Unions are types of objects that can represent one of many different object types.

Examples of unions:
- `TransactedForUnion`
- `OrderUnion`
- `MessageParticipantUnion`
- `TaskableUnion`
- `TransactionUnion`
- `MessageUnion`

For more information, see [the GraphQL spec](https://facebook.github.io/graphql/#sec-Unions).

================
File: docs/README.md
================
# SanMar Auto Order Integration

## Project Overview
This project provides an automated integration between SanMar's SOAP API and Printavo's GraphQL API for streamlined order processing in the apparel printing industry. It automates the process of extracting order information from SanMar invoices using OCR technology and creating corresponding orders in Printavo's system.

## Key Features
- **OCR Invoice Processing**: Automatically extracts data from SanMar PDF invoices using Tesseract OCR
- **Multi-Page PDF Support**: Handles multi-page PDF documents, combining OCR results from all pages
- **Printavo Integration**: Creates and manages orders in Printavo using their GraphQL API
- **Data Validation**: Comprehensive validation of all data before submission to Printavo
- **Error Handling**: Robust error handling with retries for API rate limits and network issues
- **Logging**: Detailed logging system with request tracking and sensitive data masking

## Target Audience
This project is designed for:
- Screen printing and embroidery shops using Printavo for order management
- Businesses that regularly order from SanMar and need automated order processing
- Developers integrating SanMar and Printavo systems

## Example Use Cases

1. **Automated Order Creation**
   ```
   A print shop receives a SanMar invoice PDF. They upload it to the system, which automatically extracts the order details and creates a new order in Printavo with all the correct line items, quantities, and customer information.
   ```

2. **Bulk Invoice Processing**
   ```
   A large print shop receives multiple SanMar invoices daily. They can process all invoices at once, with the system handling the OCR extraction and Printavo order creation for each invoice automatically.
   ```

3. **Order Validation**
   ```
   Before creating orders in Printavo, the system validates all extracted data, ensuring accurate information transfer and preventing errors in the order process.
   ```

## Getting Started
1. Install dependencies:
   ```bash
   npm install
   ```

2. Configure environment variables:
   ```bash
   cp .env.example .env
   # Edit .env with your Printavo and SanMar credentials
   ```

3. Start the service:
   ```bash
   npm start
   ```

4. Access the API at `http://localhost:3000`

================
File: docs/Sanmar/Sanmar_integration.md
================
# SanMar Purchase Order Integration Guide v21.9

## Authentication
- Use your existing SanMar username and password.
- Setup separate web user accounts at [SanMar Webuser Signup](https://www.sanmar.com/signup/webuser).
- Contact **sanmarintegrations@sanmar.com** for EDEV setup or integration requests.

## Integration Overview
SanMar supports FTP and SOAP-based Web Service integration for automated order processing.

### Supported Web Services
1. **getPreSubmitInfo**: Confirms inventory availability from the closest warehouse.
2. **submitPO**: Submits purchase orders for processing.
3. **PromoStandards SendPO**: For detailed and configurable purchase orders.

### WSDL Endpoints
- **EDEV Environment**: [https://edev-ws.sanmar.com:8080/SanMarWebService/SanMarPOServicePort?wsdl](https://edev-ws.sanmar.com:8080/SanMarWebService/SanMarPOServicePort?wsdl)
- **Production Environment**: [https://ws.sanmar.com:8080/SanMarWebService/SanMarPOServicePort?wsdl](https://ws.sanmar.com:8080/SanMarWebService/SanMarPOServicePort?wsdl)

## File-Based FTP Order Integration
FTP integration uses three required files:
1. **CustInfo.txt**: Shipping information.
2. **Details.txt**: Product information.
3. **Release.txt**: Authorizes processing.

### File Naming Convention
Files must include:
- Date in MM-DD-YYYY format.
- Batch number for the day.
- File type (e.g., `CustInfo`, `Details`, or `Release`).

Example:
```
06-07-2022-1CustInfo.txt
06-07-2022-1Details.txt
06-07-2022-1Release.txt
```

### File Submission Timing
- Upload `CustInfo.txt` and `Details.txt` first.
- Add a timing delay before submitting the corresponding `Release.txt`.

### CustInfo.txt Format
| Field Name         | Description                             | Required |
|--------------------|-----------------------------------------|----------|
| PONUM             | Purchase Order Number                  | Yes      |
| Address 1         | Street Address                         | Yes      |
| City              | City Name                              | Yes      |
| State             | 2-Character State Code                 | Yes      |
| ZIP Code          | 5-9 Digit Zip Code                     | Yes      |
| Email             | Shipping Notification Email            | Yes      |
| Shipping Method   | UPS or USPS                            | Yes      |
| Residence         | `Y` or `N`                             | Yes      |

### Details.txt Format
| Field Name         | Description                             | Required |
|--------------------|-----------------------------------------|----------|
| PONUM             | Purchase Order Number                  | Yes      |
| Inventory Key     | Product Identifier from SanMar Database | Yes      |
| Quantity          | Quantity Ordered                       | Yes      |
| Size Index        | Product Size Identifier                | Yes      |
| Warehouse Number  | Leave Blank or Specify (Optional)      | No       |

### Release.txt Format
| Field Name | Description              | Required |
|------------|--------------------------|----------|
| PONUM     | Purchase Order Number   | Yes      |

Example:
```
FX34689
```

### Holding.txt File
- Contains order acknowledgments, including:
  - Warehouse availability (`Y` or `N`).
  - Product details (style, color, size).

### Folder Structure
- `In` and `Release`: For incoming files.
- `Holding`: For acknowledgments.
- `Done`: Processed files.
- `ErrorFiles`: For invalid files.

## Web Service Integration

### getPreSubmitInfo
Confirms inventory availability. Key parameters:
- **poNum**: Purchase Order Number.
- **shipAddress1**, **shipCity**, **shipState**, **shipZip**: Shipping details.
- **style**, **color**, **size**: Product details.
- **quantity**: Requested quantity.

Response example:
```xml
<webServicePoDetailList>
  <message>Requested Quantity is confirmed and available in warehouse '1'.</message>
  <whseNo>1</whseNo>
</webServicePoDetailList>
```

### submitPO
Submits a purchase order for processing. Key parameters:
- **poNum**: Purchase Order Number.
- **shipTo**, **shipAddress1**, **shipCity**, **shipState**, **shipZip**: Shipping details.
- **style**, **color**, **size**, **quantity**: Product details.

Request example:
```xml
<soapenv:Envelope>
  <soapenv:Body>
    <web:submitPO>
      <poNum>Integration Test Order</poNum>
      <shipTo>SanMar Corporation</shipTo>
      <webServicePoDetailList>
        <style>K420</style>
        <color>Black</color>
        <size>S</size>
        <quantity>10</quantity>
      </webServicePoDetailList>
    </web:submitPO>
  </soapenv:Body>
</soapenv:Envelope>
```

Response example:
```xml
<message>PO Submission successful</message>
```

### PromoStandards SendPO
Used for configurable and detailed orders. Key parameters:
- **orderType**: Type of order (e.g., Blank, Sample).
- **orderNumber**: PO Number.
- **carrier**: Shipping method (e.g., UPS Ground).

Request example:
```xml
<soapenv:Envelope>
  <soapenv:Body>
    <ns:SendPORequest>
      <ns:orderType>Blank</ns:orderType>
      <ns:orderNumber>TEST01</ns:orderNumber>
      <ns:carrier>UPS</ns:carrier>
      <ns:service>Ground</ns:service>
    </ns:SendPORequest>
  </soapenv:Body>
</soapenv:Envelope>
```

Response example:
```xml
<transactionId>TEST01-p-5877</transactionId>
```

## Additional Notes
- Contact **sanmarintegrations@sanmar.com** for assistance.
- Setup testing in the EDEV environment before production.
- Avoid duplicate line items in order submissions to prevent errors.

---

This Markdown file retains only essential details while removing repetitive or unnecessary information. You can save this under `docs/sanmar_integration.md` in your codebase.

================
File: docs/setup.md
================
# Setup and Installation

## Prerequisites

### Required Software
- Node.js (v18.x or later)
- npm (v9.x or later)
- Git

### System Requirements
- Operating System: Windows, macOS, or Linux
- Memory: Minimum 4GB RAM (8GB recommended)
- Storage: At least 1GB free space

## Installation Steps

1. **Clone the Repository**
   ```bash
   git clone https://github.com/your-org/sanmar-auto-order.git
   cd sanmar-auto-order
   ```

2. **Install Dependencies**
   ```bash
   npm install
   ```

3. **Configure Environment Variables**
   Create a `.env` file in the root directory:
   ```env
   # Printavo API Configuration
   PRINTAVO_API_URL=https://www.printavo.com/api/v2
   PRINTAVO_EMAIL=sales@kingclothing.com
   PRINTAVO_ACCESS_TOKEN=uyZXl2kWJNSXwR_MXMuNWQ

   # Server Configuration
   PORT=3000
   NODE_ENV=development

   # MongoDB Configuration (if using database)
   MONGODB_URI=mongodb://localhost:27017/sanmar_auto_order
   ```

4. **Verify Installation**
   ```bash
   npm run test
   ```

## Configuration

### Environment Variables

| Variable | Description | Required | Default |
|----------|-------------|----------|---------|
| `PRINTAVO_API_URL` | Printavo API endpoint | Yes | - |
| `PRINTAVO_EMAIL` | Printavo account email | Yes | - |
| `PRINTAVO_ACCESS_TOKEN` | Printavo API token | Yes | - |
| `PORT` | Server port number | No | 3000 |
| `NODE_ENV` | Environment mode | No | development |
| `MONGODB_URI` | MongoDB connection string | No | - |

### API Rate Limits

The Printavo API has the following rate limits:
- Maximum 10 requests per 5 seconds
- Per user email or IP address

### Security Configuration

1. **API Token**
   - Obtain from Printavo's My Account page
   - Store securely in environment variables
   - Never commit tokens to version control

2. **CORS Configuration**
   ```javascript
   // Update in app.js if needed
   app.use(cors({
     origin: process.env.ALLOWED_ORIGINS?.split(',') || '*'
   }));
   ```

## Development Setup

1. **Install Development Dependencies**
   ```bash
   npm install --save-dev nodemon
   ```

2. **Start Development Server**
   ```bash
   npm run dev
   ```

3. **Enable Debug Logging**
   ```bash
   DEBUG=printavo:* npm run dev
   ```

## Production Deployment

1. **Environment Setup**
   ```bash
   # Set production environment
   export NODE_ENV=production
   ```

2. **Security Checklist**
   - [ ] Set secure environment variables
   - [ ] Configure proper CORS settings
   - [ ] Enable rate limiting
   - [ ] Set up error logging
   - [ ] Configure SSL/TLS

3. **Start Production Server**
   ```bash
   npm start
   ```

## Troubleshooting

### Common Issues

1. **API Authentication Errors**
   ```
   Error: Failed to authenticate with Printavo API
   ```
   - Verify email and token in `.env`
   - Check API URL format
   - Ensure account has API access

2. **OCR Processing Issues**
   ```
   Error: Failed to process PDF
   ```
   - Check PDF file permissions
   - Verify Tesseract.js installation
   - Ensure sufficient memory

3. **Rate Limiting**
   ```
   Error: Too many requests
   ```
   - Check request frequency
   - Implement request queuing
   - Add delay between requests

### Debug Mode

Enable detailed logging:
```bash
# Windows
set DEBUG=printavo:*
# Unix
export DEBUG=printavo:*
```

### Support

For additional support:
1. Check the [GitHub Issues](https://github.com/your-org/sanmar-auto-order/issues)
2. Review the [API Documentation](https://www.printavo.com/api/v2/docs)
3. Contact [support@example.com](mailto:support@example.com)

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
